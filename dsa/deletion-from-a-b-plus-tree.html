<!DOCTYPE html>

<html lang="en">
<head>
<title>Delete From B+ Tree</title>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-HCERBDV76D"></script>
<script>

        window.dataLayer = window.dataLayer || [];

        function gtag() { dataLayer.push(arguments); }

        gtag('js', new Date());



        gtag('config', 'G-HCERBDV76D');

    </script>
<meta content="B0487B46A104E90209E8A3BEA24ECA0E" name="msvalidate.01"/>
<meta content="f044b3a12c7918f1" name="yandex-verification"/>
<!--end-->
<meta content="learn about data types, variables, lists, tuples, dictionaries,if else,DSA,loops,user-defined functions, oop, threading and scripting." name="description"/>
<meta content="learnPython" name="author"/>
<meta content="Learn Python for free,learn python for beginners,Core Python,Web frameworks,Multiprocess architecture,Serverside templating language,python tutorials,python4" name="keywords"/>
<meta content="website" property="og:type"/>
<meta content="US-CA" name="”geo.region”"/>
<meta content="353 Jane Stanford Way, Stanford, CA 94305, United States" name="”geo.placename”"/>
<meta content="37.430089898615456;-122.17332683124829" name="”geo.position”"/>
<meta content="37.430089898615456, -122.17332683124829" name="”ICBM”"/>
<link href="https://pythonread.github.io/?m=1" rel="alternate"/>
<link href="/favicon.png" rel="icon"/>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="/style1.css" media="all" rel="stylesheet" type="text/css"/>
<link href="/style2.css" media="all" rel="stylesheet" type="text/css"/>
<link href="/style0.css" media="all" rel="stylesheet" type="text/css"/>
<!--<![endif]-->
</head>
<body>
<div class="nav-wrapper">
<div class="container">
<nav>
<div class="logo wave">
<a href="/" id="logo">

                        Python Tutorial

                    </a>
</div>
<div class="nav-toggle-icon" id="nav-toggle-icon" onclick="mobileMenu()">
<div class="material-hamburger">
<span>
</span>
<span>
</span>
<span>
</span>
</div>
</div>
<div class="menu-wrapper" id="menu-wrapper">
<div class="nav-indicator">
</div>
<ul class="menus">
<li>
<a class="wave" href="/">

                                Home

                            </a>
</li>
<li>
<a class="wave" href="/projects.html">

                                Projects

                            </a>
</li>
<li>
<a class="wave" href="/free-course.html" target="_blank">

                                Free Course

                            </a>
</li>
<li>
<a class="wave" href="/dsa.html">

                                DSA

                            </a>
</li>
</ul>
</div>
</nav>
</div>
</div>
<div class="contents contents--neg" style="margin-top: 60px">
<div class="container">
<div class="row">
<div class="col-sm-12">
<div class="d-flex">
<div class="left-bar d-none d-lg-block">
<div class="card-alt mb-10x">
<h3>Page Index</h3>
<div class="list">
<ul>
<li><a href="/dsa.html#data-structure-1" title="Data Structures (I)">Data Structures

                                                (I)</a></li>
<li><a href="/dsa.html#data-structure-2" title="Data Structures (II)">Data Structures

                                                (II)</a></li>
<li><a href="/dsa.html#tree-1" title="Tree based DSA (I)">Tree based DSA (I)</a></li>
<li><a href="/dsa.html#tree-2" title="Tree based DSA (II)">Tree based DSA (II)</a></li>
<li><a href="/dsa.html#graph" title="Graph Data Structures and Algorithm">Graph based

                                                DSA</a></li>
<li><a href="/dsa.html#sorting-searching" title="Sorting and Searching">Sorting and

                                                Searching</a></li>
<li><a href="/dsa.html#greedy-algorithm" title="Greedy Algorithms">Greedy Algorithms</a>
</li>
<li><a href="/dsa.html#dynamic-programming" title="Dynamic Programming">Dynamic

                                                Programming</a></li>
<li><a href="/dsa.html#other-algorithms" title="Other Algorithms">Other Algorithms</a>
</li>
</ul>
</div>
</div>
</div>
<div class="right-bar">
<!--first part end-------------------------------------------->

<div class="editor-contents">
        <h1>Deletion from a B+ Tree</h1>


        <p class="editor-contents__short-description">In this tutorial, you will learn about deletion operation on a B+ tree. Also, you will find working examples of deleting elements from a B+ tree in C, C++, Java and Python.</p>



          



<div id="node-1659" class="node node-algorithm clearfix" about="/dsa/deletion-from-a-b-plus-tree" typeof="sioc:Item foaf:Document">


<span property="dc:title" content="Deletion from a B+ Tree" class="rdf-meta element-hidden"></span>

<div class="content">
<p id="definition">Deleting an element on a B+ tree consists of three main events: <strong>searching</strong> the node where the key to be deleted exists, deleting the key and balancing the tree if required.<strong>Underflow</strong> is a situation when there is less number of keys in a node than the minimum number of keys it should hold.</p>

<hr><h2 id="deletion">Deletion Operation</h2>

<p>Before going through the steps below, one must know these facts about a B+ tree of degree <strong>m</strong>.</p>

<ol><li>A node can have a maximum of m children. (i.e. 3)</li>
<li>A node can contain a maximum of <code>m - 1</code> keys. (i.e. 2)</li>
<li>A node should have a minimum of <code>⌈m/2⌉</code> children. (i.e. 2)</li>
<li>A node (except root node) should contain a minimum of <code>⌈m/2⌉ - 1</code> keys. (i.e. 1)</li>
</ol><p>While deleting a key, we have to take care of the keys present in the internal nodes (i.e. indexes) as well because the values are redundant in a B+ tree. Search the key to be deleted then follow the following steps.</p>

<h3>Case I</h3>

<p>The key to be deleted is present only at the leaf node not in the indexes (or internal nodes). There are two cases for it:</p>

<ol><li>There is more than the minimum number of keys in the node. Simply delete the key.
<figure><img alt="Delete a key from a B+tree" src="//cdn.programiz.com/sites/tutorial2program/files/deletion-1-b+tree.png" title="Deletion from a B+ tree" width="488" height="460"><figcaption>Deleting 40 from B-tree</figcaption></figure></li>
<li>There is an exact minimum number of keys in the node. Delete the key and borrow a key from the immediate sibling. Add the median key of the sibling node to the parent.
<figure><img alt="Delete a key from a B+tree" src="//cdn.programiz.com/sites/tutorial2program/files/deletion-2-b+tree.png" title="Deletion from a B+ tree" width="496" height="704"><figcaption>Deleting 5 from B-tree</figcaption></figure></li>
</ol><h3>Case II</h3>

<p>The key to be deleted is present in the internal nodes as well. Then we have to remove them from the internal nodes as well. There are the following cases for this situation.</p>

<ol><li>If there is more than the minimum number of keys in the node, simply delete the key from the leaf node and delete the key from the internal node as well.<br>
Fill the empty space in the internal node with the inorder successor.
<figure><img alt="Delete a key from a B+tree" src="//cdn.programiz.com/sites/tutorial2program/files/deletion-3-b+tree_0.png" title="Deletion from a B+ tree" width="448" height="704"><figcaption>Deleting 45 from B-tree</figcaption></figure></li>
<li>If there is an exact minimum number of keys in the node, then delete the key and borrow a key from its immediate sibling (through the parent).<br>
Fill the empty space created in the index (internal node) with the borrowed key.
<figure><img alt="Delete a key from a B+tree" src="//cdn.programiz.com/sites/tutorial2program/files/deletion-4-b+tree.png" title="Deletion from a B+ tree" width="409" height="704"><figcaption>Deleting 35 from B-tree</figcaption></figure></li>
<li>This case is similar to Case II(1) but here, empty space is generated above the immediate parent node.<br>
After deleting the key, merge the empty space with its sibling.<br>
Fill the empty space in the grandparent node with the inorder successor.
<figure><img alt="Delete a key from a B+tree" src="//cdn.programiz.com/sites/tutorial2program/files/deletion-5-b+tree.png" title="Deletion from a B+ tree" width="399" height="948"><figcaption>Deleting 25 from B-tree</figcaption></figure></li>
</ol><h3>Case III</h3>

<p></p><div class="clearfix"></div><p>In this case, the height of the tree gets shrinked. It is a little complicated.Deleting 55 from the tree below leads to this condition. It can be understood in the illustrations below.</p>

<figure><img alt="Delete a key from a B+tree" src="//cdn.programiz.com/sites/tutorial2program/files/deletion-6-b+tree.png" title="Deletion from a B+ tree" width="328" height="884"><figcaption>Deleting 55 from B-tree</figcaption></figure><hr><h2 id="code">Python, Java and C/C++ Examples</h2>

<div class="tabbed-editor">
        <div id="py1" onclick="changepy()" class="tabbed-editor__node tabbed-editor__node--active"><a href="#python-code">Python</a></div>
        
        <div id="java1" onclick="changejava()"  class="tabbed-editor__node"><a href="#java-code">Java</a></div>
        
        <div id="c1" onclick="changec()" class="tabbed-editor__node"><a href="#c-code">C</a></div>
        
        <div id="cpp1" onclick="changecpp()" class="tabbed-editor__node"><a href="#cpp-code">C++</a></div>
        </div>

<div class="code-editor code-editor--tabbed">
<div class="code-editor__area code-editor__area--active" id="python-code">
<div class="pre-code-wrapper"><div title="Click to copy" class="copy-code-button"></div><pre class="exec" style="max-height: 600px;"><code class="python hljs"><span class="hljs-comment"># B+ tee in python</span>


<span class="hljs-keyword">import</span> math

<span class="hljs-comment"># Node creation</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>:</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, order)</span>:</span>
self.order = order
self.values = []
self.keys = []
self.nextKey = <span class="hljs-literal">None</span>
self.parent = <span class="hljs-literal">None</span>
self.check_leaf = <span class="hljs-literal">False</span>

<span class="hljs-comment"># Insert at the leaf</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert_at_leaf</span><span class="hljs-params">(self, leaf, value, key)</span>:</span>
<span class="hljs-keyword">if</span> (self.values):
temp1 = self.values
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(temp1)):
<span class="hljs-keyword">if</span> (value == temp1[i]):
self.keys[i].append(key)
<span class="hljs-keyword">break</span>
<span class="hljs-keyword">elif</span> (value &lt; temp1[i]):
self.values = self.values[:i] + [value] + self.values[i:]
self.keys = self.keys[:i] + [[key]] + self.keys[i:]
<span class="hljs-keyword">break</span>
<span class="hljs-keyword">elif</span> (i + <span class="hljs-number">1</span> == len(temp1)):
self.values.append(value)
self.keys.append([key])
<span class="hljs-keyword">break</span>
<span class="hljs-keyword">else</span>:
self.values = [value]
self.keys = [[key]]


<span class="hljs-comment"># B plus tree</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BplusTree</span>:</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, order)</span>:</span>
self.root = Node(order)
self.root.check_leaf = <span class="hljs-literal">True</span>

<span class="hljs-comment"># Insert operation</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span><span class="hljs-params">(self, value, key)</span>:</span>
value = str(value)
old_node = self.search(value)
old_node.insert_at_leaf(old_node, value, key)

<span class="hljs-keyword">if</span> (len(old_node.values) == old_node.order):
node1 = Node(old_node.order)
node1.check_leaf = <span class="hljs-literal">True</span>
node1.parent = old_node.parent
mid = int(math.ceil(old_node.order / <span class="hljs-number">2</span>)) - <span class="hljs-number">1</span>
node1.values = old_node.values[mid + <span class="hljs-number">1</span>:]
node1.keys = old_node.keys[mid + <span class="hljs-number">1</span>:]
node1.nextKey = old_node.nextKey
old_node.values = old_node.values[:mid + <span class="hljs-number">1</span>]
old_node.keys = old_node.keys[:mid + <span class="hljs-number">1</span>]
old_node.nextKey = node1
self.insert_in_parent(old_node, node1.values[<span class="hljs-number">0</span>], node1)

<span class="hljs-comment"># Search operation for different operations</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span><span class="hljs-params">(self, value)</span>:</span>
current_node = self.root
<span class="hljs-keyword">while</span>(current_node.check_leaf == <span class="hljs-literal">False</span>):
temp2 = current_node.values
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(temp2)):
<span class="hljs-keyword">if</span> (value == temp2[i]):
current_node = current_node.keys[i + <span class="hljs-number">1</span>]
<span class="hljs-keyword">break</span>
<span class="hljs-keyword">elif</span> (value &lt; temp2[i]):
current_node = current_node.keys[i]
<span class="hljs-keyword">break</span>
<span class="hljs-keyword">elif</span> (i + <span class="hljs-number">1</span> == len(current_node.values)):
current_node = current_node.keys[i + <span class="hljs-number">1</span>]
<span class="hljs-keyword">break</span>
<span class="hljs-keyword">return</span> current_node

<span class="hljs-comment"># Find the node</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span><span class="hljs-params">(self, value, key)</span>:</span>
l = self.search(value)
<span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> enumerate(l.values):
<span class="hljs-keyword">if</span> item == value:
<span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> l.keys[i]:
<span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
<span class="hljs-keyword">else</span>:
<span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
<span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

<span class="hljs-comment"># Inserting at the parent</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert_in_parent</span><span class="hljs-params">(self, n, value, ndash)</span>:</span>
<span class="hljs-keyword">if</span> (self.root == n):
rootNode = Node(n.order)
rootNode.values = [value]
rootNode.keys = [n, ndash]
self.root = rootNode
n.parent = rootNode
ndash.parent = rootNode
<span class="hljs-keyword">return</span>

parentNode = n.parent
temp3 = parentNode.keys
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(temp3)):
<span class="hljs-keyword">if</span> (temp3[i] == n):
parentNode.values = parentNode.values[:i] + \
[value] + parentNode.values[i:]
parentNode.keys = parentNode.keys[:i +
                            <span class="hljs-number">1</span>] + [ndash] + parentNode.keys[i + <span class="hljs-number">1</span>:]
<span class="hljs-keyword">if</span> (len(parentNode.keys) &gt; parentNode.order):
parentdash = Node(parentNode.order)
parentdash.parent = parentNode.parent
mid = int(math.ceil(parentNode.order / <span class="hljs-number">2</span>)) - <span class="hljs-number">1</span>
parentdash.values = parentNode.values[mid + <span class="hljs-number">1</span>:]
parentdash.keys = parentNode.keys[mid + <span class="hljs-number">1</span>:]
value_ = parentNode.values[mid]
<span class="hljs-keyword">if</span> (mid == <span class="hljs-number">0</span>):
  parentNode.values = parentNode.values[:mid + <span class="hljs-number">1</span>]
<span class="hljs-keyword">else</span>:
  parentNode.values = parentNode.values[:mid]
parentNode.keys = parentNode.keys[:mid + <span class="hljs-number">1</span>]
<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> parentNode.keys:
  j.parent = parentNode
<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> parentdash.keys:
  j.parent = parentdash
self.insert_in_parent(parentNode, value_, parentdash)

<span class="hljs-comment"># Delete a node</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span><span class="hljs-params">(self, value, key)</span>:</span>
node_ = self.search(value)

temp = <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> enumerate(node_.values):
<span class="hljs-keyword">if</span> item == value:
temp = <span class="hljs-number">1</span>

<span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> node_.keys[i]:
<span class="hljs-keyword">if</span> len(node_.keys[i]) &gt; <span class="hljs-number">1</span>:
  node_.keys[i].pop(node_.keys[i].index(key))
<span class="hljs-keyword">elif</span> node_ == self.root:
  node_.values.pop(i)
  node_.keys.pop(i)
<span class="hljs-keyword">else</span>:
  node_.keys[i].pop(node_.keys[i].index(key))
  <span class="hljs-keyword">del</span> node_.keys[i]
  node_.values.pop(node_.values.index(value))
  self.deleteEntry(node_, value, key)
<span class="hljs-keyword">else</span>:
<span class="hljs-keyword">print</span>(<span class="hljs-string">"Value not in Key"</span>)
<span class="hljs-keyword">return</span>
<span class="hljs-keyword">if</span> temp == <span class="hljs-number">0</span>:
<span class="hljs-keyword">print</span>(<span class="hljs-string">"Value not in Tree"</span>)
<span class="hljs-keyword">return</span>

<span class="hljs-comment"># Delete an entry</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deleteEntry</span><span class="hljs-params">(self, node_, value, key)</span>:</span>

<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node_.check_leaf:
<span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> enumerate(node_.keys):
<span class="hljs-keyword">if</span> item == key:
node_.keys.pop(i)
<span class="hljs-keyword">break</span>
<span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> enumerate(node_.values):
<span class="hljs-keyword">if</span> item == value:
node_.values.pop(i)
<span class="hljs-keyword">break</span>

<span class="hljs-keyword">if</span> self.root == node_ <span class="hljs-keyword">and</span> len(node_.keys) == <span class="hljs-number">1</span>:
self.root = node_.keys[<span class="hljs-number">0</span>]
node_.keys[<span class="hljs-number">0</span>].parent = <span class="hljs-literal">None</span>
<span class="hljs-keyword">del</span> node_
<span class="hljs-keyword">return</span>
<span class="hljs-keyword">elif</span> (len(node_.keys) &lt; int(math.ceil(node_.order / <span class="hljs-number">2</span>)) <span class="hljs-keyword">and</span> node_.check_leaf == <span class="hljs-literal">False</span>) <span class="hljs-keyword">or</span> (len(node_.values) &lt; int(math.ceil((node_.order - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)) <span class="hljs-keyword">and</span> node_.check_leaf == <span class="hljs-literal">True</span>):

is_predecessor = <span class="hljs-number">0</span>
parentNode = node_.parent
PrevNode = <span class="hljs-number">-1</span>
NextNode = <span class="hljs-number">-1</span>
PrevK = <span class="hljs-number">-1</span>
PostK = <span class="hljs-number">-1</span>
<span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> enumerate(parentNode.keys):

<span class="hljs-keyword">if</span> item == node_:
<span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span>:
  PrevNode = parentNode.keys[i - <span class="hljs-number">1</span>]
  PrevK = parentNode.values[i - <span class="hljs-number">1</span>]

<span class="hljs-keyword">if</span> i &lt; len(parentNode.keys) - <span class="hljs-number">1</span>:
  NextNode = parentNode.keys[i + <span class="hljs-number">1</span>]
  PostK = parentNode.values[i]

<span class="hljs-keyword">if</span> PrevNode == <span class="hljs-number">-1</span>:
ndash = NextNode
value_ = PostK
<span class="hljs-keyword">elif</span> NextNode == <span class="hljs-number">-1</span>:
is_predecessor = <span class="hljs-number">1</span>
ndash = PrevNode
value_ = PrevK
<span class="hljs-keyword">else</span>:
<span class="hljs-keyword">if</span> len(node_.values) + len(NextNode.values) &lt; node_.order:
ndash = NextNode
value_ = PostK
<span class="hljs-keyword">else</span>:
is_predecessor = <span class="hljs-number">1</span>
ndash = PrevNode
value_ = PrevK

<span class="hljs-keyword">if</span> len(node_.values) + len(ndash.values) &lt; node_.order:
<span class="hljs-keyword">if</span> is_predecessor == <span class="hljs-number">0</span>:
node_, ndash = ndash, node_
ndash.keys += node_.keys
<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node_.check_leaf:
ndash.values.append(value_)
<span class="hljs-keyword">else</span>:
ndash.nextKey = node_.nextKey
ndash.values += node_.values

<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ndash.check_leaf:
<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> ndash.keys:
  j.parent = ndash

self.deleteEntry(node_.parent, value_, node_)
<span class="hljs-keyword">del</span> node_
<span class="hljs-keyword">else</span>:
<span class="hljs-keyword">if</span> is_predecessor == <span class="hljs-number">1</span>:
<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node_.check_leaf:
  ndashpm = ndash.keys.pop(<span class="hljs-number">-1</span>)
  ndashkm_1 = ndash.values.pop(<span class="hljs-number">-1</span>)
  node_.keys = [ndashpm] + node_.keys
  node_.values = [value_] + node_.values
  parentNode = node_.parent
  <span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> enumerate(parentNode.values):
      <span class="hljs-keyword">if</span> item == value_:
          p.values[i] = ndashkm_1
          <span class="hljs-keyword">break</span>
<span class="hljs-keyword">else</span>:
  ndashpm = ndash.keys.pop(<span class="hljs-number">-1</span>)
  ndashkm = ndash.values.pop(<span class="hljs-number">-1</span>)
  node_.keys = [ndashpm] + node_.keys
  node_.values = [ndashkm] + node_.values
  parentNode = node_.parent
  <span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> enumerate(p.values):
      <span class="hljs-keyword">if</span> item == value_:
          parentNode.values[i] = ndashkm
          <span class="hljs-keyword">break</span>
<span class="hljs-keyword">else</span>:
<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node_.check_leaf:
  ndashp0 = ndash.keys.pop(<span class="hljs-number">0</span>)
  ndashk0 = ndash.values.pop(<span class="hljs-number">0</span>)
  node_.keys = node_.keys + [ndashp0]
  node_.values = node_.values + [value_]
  parentNode = node_.parent
  <span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> enumerate(parentNode.values):
      <span class="hljs-keyword">if</span> item == value_:
          parentNode.values[i] = ndashk0
          <span class="hljs-keyword">break</span>
<span class="hljs-keyword">else</span>:
  ndashp0 = ndash.keys.pop(<span class="hljs-number">0</span>)
  ndashk0 = ndash.values.pop(<span class="hljs-number">0</span>)
  node_.keys = node_.keys + [ndashp0]
  node_.values = node_.values + [ndashk0]
  parentNode = node_.parent
  <span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> enumerate(parentNode.values):
      <span class="hljs-keyword">if</span> item == value_:
          parentNode.values[i] = ndash.values[<span class="hljs-number">0</span>]
          <span class="hljs-keyword">break</span>

<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ndash.check_leaf:
<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> ndash.keys:
  j.parent = ndash
<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node_.check_leaf:
<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> node_.keys:
  j.parent = node_
<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> parentNode.check_leaf:
<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> parentNode.keys:
  j.parent = parentNode


<span class="hljs-comment"># Print the tree</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printTree</span><span class="hljs-params">(tree)</span>:</span>
lst = [tree.root]
level = [<span class="hljs-number">0</span>]
leaf = <span class="hljs-literal">None</span>
flag = <span class="hljs-number">0</span>
lev_leaf = <span class="hljs-number">0</span>

node1 = Node(str(level[<span class="hljs-number">0</span>]) + str(tree.root.values))

<span class="hljs-keyword">while</span> (len(lst) != <span class="hljs-number">0</span>):
x = lst.pop(<span class="hljs-number">0</span>)
lev = level.pop(<span class="hljs-number">0</span>)
<span class="hljs-keyword">if</span> (x.check_leaf == <span class="hljs-literal">False</span>):
<span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> enumerate(x.keys):
<span class="hljs-keyword">print</span>(item.values)
<span class="hljs-keyword">else</span>:
<span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> enumerate(x.keys):
<span class="hljs-keyword">print</span>(item.values)
<span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>):
lev_leaf = lev
leaf = x
flag = <span class="hljs-number">1</span>


record_len = <span class="hljs-number">3</span>
bplustree = BplusTree(record_len)
bplustree.insert(<span class="hljs-string">'5'</span>, <span class="hljs-string">'33'</span>)
bplustree.insert(<span class="hljs-string">'15'</span>, <span class="hljs-string">'21'</span>)
bplustree.insert(<span class="hljs-string">'25'</span>, <span class="hljs-string">'31'</span>)
bplustree.insert(<span class="hljs-string">'35'</span>, <span class="hljs-string">'41'</span>)
bplustree.insert(<span class="hljs-string">'45'</span>, <span class="hljs-string">'10'</span>)

printTree(bplustree)

<span class="hljs-keyword">if</span>(bplustree.find(<span class="hljs-string">'5'</span>, <span class="hljs-string">'34'</span>)):
<span class="hljs-keyword">print</span>(<span class="hljs-string">"Found"</span>)
<span class="hljs-keyword">else</span>:
<span class="hljs-keyword">print</span>(<span class="hljs-string">"Not found"</span>)</code></pre></div>
</div>

<div class="code-editor__area" id="java-code">
<div class="pre-code-wrapper"><div title="Click to copy" class="copy-code-button"></div><pre class="exec" style="max-height: 600px;"><code class="java hljs">
<span class="hljs-comment">// Searching on a B+ tree in Java</span>
<span class="hljs-keyword">import</span> java.util.*;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BPlusTree</span> </span>{
<span class="hljs-keyword">int</span> m;
InternalNode root;
LeafNode firstLeaf;

<span class="hljs-comment">// Binary search program</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(DictionaryPair[] dps, <span class="hljs-keyword">int</span> numPairs, <span class="hljs-keyword">int</span> t)</span> </span>{
Comparator&lt;DictionaryPair&gt; c = <span class="hljs-keyword">new</span> Comparator&lt;DictionaryPair&gt;() {
<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(DictionaryPair o1, DictionaryPair o2)</span> </span>{
Integer a = Integer.valueOf(o1.key);
Integer b = Integer.valueOf(o2.key);
<span class="hljs-keyword">return</span> a.compareTo(b);
}
};
<span class="hljs-keyword">return</span> Arrays.binarySearch(dps, <span class="hljs-number">0</span>, numPairs, <span class="hljs-keyword">new</span> DictionaryPair(t, <span class="hljs-number">0</span>), c);
}

<span class="hljs-comment">// Find the leaf node</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> LeafNode <span class="hljs-title">findLeafNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>{

Integer[] keys = <span class="hljs-keyword">this</span>.root.keys;
<span class="hljs-keyword">int</span> i;

<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.root.degree - <span class="hljs-number">1</span>; i++) {
<span class="hljs-keyword">if</span> (key &lt; keys[i]) {
<span class="hljs-keyword">break</span>;
}
}

Node child = <span class="hljs-keyword">this</span>.root.childPointers[i];
<span class="hljs-keyword">if</span> (child <span class="hljs-keyword">instanceof</span> LeafNode) {
<span class="hljs-keyword">return</span> (LeafNode) child;
} <span class="hljs-keyword">else</span> {
<span class="hljs-keyword">return</span> findLeafNode((InternalNode) child, key);
}
}

<span class="hljs-comment">// Find the leaf node</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> LeafNode <span class="hljs-title">findLeafNode</span><span class="hljs-params">(InternalNode node, <span class="hljs-keyword">int</span> key)</span> </span>{

Integer[] keys = node.keys;
<span class="hljs-keyword">int</span> i;

<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; node.degree - <span class="hljs-number">1</span>; i++) {
<span class="hljs-keyword">if</span> (key &lt; keys[i]) {
<span class="hljs-keyword">break</span>;
}
}
Node childNode = node.childPointers[i];
<span class="hljs-keyword">if</span> (childNode <span class="hljs-keyword">instanceof</span> LeafNode) {
<span class="hljs-keyword">return</span> (LeafNode) childNode;
} <span class="hljs-keyword">else</span> {
<span class="hljs-keyword">return</span> findLeafNode((InternalNode) node.childPointers[i], key);
}
}

<span class="hljs-comment">// Finding the index of the pointer</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findIndexOfPointer</span><span class="hljs-params">(Node[] pointers, LeafNode node)</span> </span>{
<span class="hljs-keyword">int</span> i;
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; pointers.length; i++) {
<span class="hljs-keyword">if</span> (pointers[i] == node) {
<span class="hljs-keyword">break</span>;
}
}
<span class="hljs-keyword">return</span> i;
}

<span class="hljs-comment">// Get the mid point</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMidpoint</span><span class="hljs-params">()</span> </span>{
<span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) Math.ceil((<span class="hljs-keyword">this</span>.m + <span class="hljs-number">1</span>) / <span class="hljs-number">2.0</span>) - <span class="hljs-number">1</span>;
}

<span class="hljs-comment">// Balance the tree</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDeficiency</span><span class="hljs-params">(InternalNode in)</span> </span>{

InternalNode sibling;
InternalNode parent = in.parent;

<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.root == in) {
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; in.childPointers.length; i++) {
<span class="hljs-keyword">if</span> (in.childPointers[i] != <span class="hljs-keyword">null</span>) {
<span class="hljs-keyword">if</span> (in.childPointers[i] <span class="hljs-keyword">instanceof</span> InternalNode) {
<span class="hljs-keyword">this</span>.root = (InternalNode) in.childPointers[i];
<span class="hljs-keyword">this</span>.root.parent = <span class="hljs-keyword">null</span>;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (in.childPointers[i] <span class="hljs-keyword">instanceof</span> LeafNode) {
<span class="hljs-keyword">this</span>.root = <span class="hljs-keyword">null</span>;
}
}
}
}

<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (in.leftSibling != <span class="hljs-keyword">null</span> &amp;&amp; in.leftSibling.isLendable()) {
sibling = in.leftSibling;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (in.rightSibling != <span class="hljs-keyword">null</span> &amp;&amp; in.rightSibling.isLendable()) {
sibling = in.rightSibling;

<span class="hljs-keyword">int</span> borrowedKey = sibling.keys[<span class="hljs-number">0</span>];
Node pointer = sibling.childPointers[<span class="hljs-number">0</span>];

in.keys[in.degree - <span class="hljs-number">1</span>] = parent.keys[<span class="hljs-number">0</span>];
in.childPointers[in.degree] = pointer;

parent.keys[<span class="hljs-number">0</span>] = borrowedKey;

sibling.removePointer(<span class="hljs-number">0</span>);
Arrays.sort(sibling.keys);
sibling.removePointer(<span class="hljs-number">0</span>);
shiftDown(in.childPointers, <span class="hljs-number">1</span>);
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (in.leftSibling != <span class="hljs-keyword">null</span> &amp;&amp; in.leftSibling.isMergeable()) {

} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (in.rightSibling != <span class="hljs-keyword">null</span> &amp;&amp; in.rightSibling.isMergeable()) {
sibling = in.rightSibling;
sibling.keys[sibling.degree - <span class="hljs-number">1</span>] = parent.keys[parent.degree - <span class="hljs-number">2</span>];
Arrays.sort(sibling.keys, <span class="hljs-number">0</span>, sibling.degree);
parent.keys[parent.degree - <span class="hljs-number">2</span>] = <span class="hljs-keyword">null</span>;

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; in.childPointers.length; i++) {
<span class="hljs-keyword">if</span> (in.childPointers[i] != <span class="hljs-keyword">null</span>) {
sibling.prependChildPointer(in.childPointers[i]);
in.childPointers[i].parent = sibling;
in.removePointer(i);
}
}

parent.removePointer(in);

sibling.leftSibling = in.leftSibling;
}

<span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span> &amp;&amp; parent.isDeficient()) {
handleDeficiency(parent);
}
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>{
<span class="hljs-keyword">return</span> firstLeaf == <span class="hljs-keyword">null</span>;
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">linearNullSearch</span><span class="hljs-params">(DictionaryPair[] dps)</span> </span>{
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dps.length; i++) {
<span class="hljs-keyword">if</span> (dps[i] == <span class="hljs-keyword">null</span>) {
<span class="hljs-keyword">return</span> i;
}
}
<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">linearNullSearch</span><span class="hljs-params">(Node[] pointers)</span> </span>{
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pointers.length; i++) {
<span class="hljs-keyword">if</span> (pointers[i] == <span class="hljs-keyword">null</span>) {
<span class="hljs-keyword">return</span> i;
}
}
<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shiftDown</span><span class="hljs-params">(Node[] pointers, <span class="hljs-keyword">int</span> amount)</span> </span>{
Node[] newPointers = <span class="hljs-keyword">new</span> Node[<span class="hljs-keyword">this</span>.m + <span class="hljs-number">1</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = amount; i &lt; pointers.length; i++) {
newPointers[i - amount] = pointers[i];
}
pointers = newPointers;
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortDictionary</span><span class="hljs-params">(DictionaryPair[] dictionary)</span> </span>{
Arrays.sort(dictionary, <span class="hljs-keyword">new</span> Comparator&lt;DictionaryPair&gt;() {
<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(DictionaryPair o1, DictionaryPair o2)</span> </span>{
<span class="hljs-keyword">if</span> (o1 == <span class="hljs-keyword">null</span> &amp;&amp; o2 == <span class="hljs-keyword">null</span>) {
<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
<span class="hljs-keyword">if</span> (o1 == <span class="hljs-keyword">null</span>) {
<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
<span class="hljs-keyword">if</span> (o2 == <span class="hljs-keyword">null</span>) {
<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}
<span class="hljs-keyword">return</span> o1.compareTo(o2);
}
});
}

<span class="hljs-keyword">private</span> Node[] splitChildPointers(InternalNode in, <span class="hljs-keyword">int</span> split) {

Node[] pointers = in.childPointers;
Node[] halfPointers = <span class="hljs-keyword">new</span> Node[<span class="hljs-keyword">this</span>.m + <span class="hljs-number">1</span>];

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = split + <span class="hljs-number">1</span>; i &lt; pointers.length; i++) {
halfPointers[i - split - <span class="hljs-number">1</span>] = pointers[i];
in.removePointer(i);
}

<span class="hljs-keyword">return</span> halfPointers;
}

<span class="hljs-keyword">private</span> DictionaryPair[] splitDictionary(LeafNode ln, <span class="hljs-keyword">int</span> split) {

DictionaryPair[] dictionary = ln.dictionary;

DictionaryPair[] halfDict = <span class="hljs-keyword">new</span> DictionaryPair[<span class="hljs-keyword">this</span>.m];

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = split; i &lt; dictionary.length; i++) {
halfDict[i - split] = dictionary[i];
ln.delete(i);
}

<span class="hljs-keyword">return</span> halfDict;
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">splitInternalNode</span><span class="hljs-params">(InternalNode in)</span> </span>{

InternalNode parent = in.parent;

<span class="hljs-keyword">int</span> midpoint = getMidpoint();
<span class="hljs-keyword">int</span> newParentKey = in.keys[midpoint];
Integer[] halfKeys = splitKeys(in.keys, midpoint);
Node[] halfPointers = splitChildPointers(in, midpoint);

in.degree = linearNullSearch(in.childPointers);

InternalNode sibling = <span class="hljs-keyword">new</span> InternalNode(<span class="hljs-keyword">this</span>.m, halfKeys, halfPointers);
<span class="hljs-keyword">for</span> (Node pointer : halfPointers) {
<span class="hljs-keyword">if</span> (pointer != <span class="hljs-keyword">null</span>) {
pointer.parent = sibling;
}
}

sibling.rightSibling = in.rightSibling;
<span class="hljs-keyword">if</span> (sibling.rightSibling != <span class="hljs-keyword">null</span>) {
sibling.rightSibling.leftSibling = sibling;
}
in.rightSibling = sibling;
sibling.leftSibling = in;

<span class="hljs-keyword">if</span> (parent == <span class="hljs-keyword">null</span>) {

Integer[] keys = <span class="hljs-keyword">new</span> Integer[<span class="hljs-keyword">this</span>.m];
keys[<span class="hljs-number">0</span>] = newParentKey;
InternalNode newRoot = <span class="hljs-keyword">new</span> InternalNode(<span class="hljs-keyword">this</span>.m, keys);
newRoot.appendChildPointer(in);
newRoot.appendChildPointer(sibling);
<span class="hljs-keyword">this</span>.root = newRoot;

in.parent = newRoot;
sibling.parent = newRoot;

} <span class="hljs-keyword">else</span> {

parent.keys[parent.degree - <span class="hljs-number">1</span>] = newParentKey;
Arrays.sort(parent.keys, <span class="hljs-number">0</span>, parent.degree);

<span class="hljs-keyword">int</span> pointerIndex = parent.findIndexOfPointer(in) + <span class="hljs-number">1</span>;
parent.insertChildPointer(sibling, pointerIndex);
sibling.parent = parent;
}
}

<span class="hljs-keyword">private</span> Integer[] splitKeys(Integer[] keys, <span class="hljs-keyword">int</span> split) {

Integer[] halfKeys = <span class="hljs-keyword">new</span> Integer[<span class="hljs-keyword">this</span>.m];

keys[split] = <span class="hljs-keyword">null</span>;

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = split + <span class="hljs-number">1</span>; i &lt; keys.length; i++) {
halfKeys[i - split - <span class="hljs-number">1</span>] = keys[i];
keys[i] = <span class="hljs-keyword">null</span>;
}

<span class="hljs-keyword">return</span> halfKeys;
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">double</span> value)</span> </span>{
<span class="hljs-keyword">if</span> (isEmpty()) {

LeafNode ln = <span class="hljs-keyword">new</span> LeafNode(<span class="hljs-keyword">this</span>.m, <span class="hljs-keyword">new</span> DictionaryPair(key, value));

<span class="hljs-keyword">this</span>.firstLeaf = ln;

} <span class="hljs-keyword">else</span> {
LeafNode ln = (<span class="hljs-keyword">this</span>.root == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">this</span>.firstLeaf : findLeafNode(key);

<span class="hljs-keyword">if</span> (!ln.insert(<span class="hljs-keyword">new</span> DictionaryPair(key, value))) {

ln.dictionary[ln.numPairs] = <span class="hljs-keyword">new</span> DictionaryPair(key, value);
ln.numPairs++;
sortDictionary(ln.dictionary);

<span class="hljs-keyword">int</span> midpoint = getMidpoint();
DictionaryPair[] halfDict = splitDictionary(ln, midpoint);

<span class="hljs-keyword">if</span> (ln.parent == <span class="hljs-keyword">null</span>) {

Integer[] parent_keys = <span class="hljs-keyword">new</span> Integer[<span class="hljs-keyword">this</span>.m];
parent_keys[<span class="hljs-number">0</span>] = halfDict[<span class="hljs-number">0</span>].key;
InternalNode parent = <span class="hljs-keyword">new</span> InternalNode(<span class="hljs-keyword">this</span>.m, parent_keys);
ln.parent = parent;
parent.appendChildPointer(ln);

} <span class="hljs-keyword">else</span> {
<span class="hljs-keyword">int</span> newParentKey = halfDict[<span class="hljs-number">0</span>].key;
ln.parent.keys[ln.parent.degree - <span class="hljs-number">1</span>] = newParentKey;
Arrays.sort(ln.parent.keys, <span class="hljs-number">0</span>, ln.parent.degree);
}

LeafNode newLeafNode = <span class="hljs-keyword">new</span> LeafNode(<span class="hljs-keyword">this</span>.m, halfDict, ln.parent);

<span class="hljs-keyword">int</span> pointerIndex = ln.parent.findIndexOfPointer(ln) + <span class="hljs-number">1</span>;
ln.parent.insertChildPointer(newLeafNode, pointerIndex);

newLeafNode.rightSibling = ln.rightSibling;
<span class="hljs-keyword">if</span> (newLeafNode.rightSibling != <span class="hljs-keyword">null</span>) {
newLeafNode.rightSibling.leftSibling = newLeafNode;
}
ln.rightSibling = newLeafNode;
newLeafNode.leftSibling = ln;

<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.root == <span class="hljs-keyword">null</span>) {

<span class="hljs-keyword">this</span>.root = ln.parent;

} <span class="hljs-keyword">else</span> {
InternalNode in = ln.parent;
<span class="hljs-keyword">while</span> (in != <span class="hljs-keyword">null</span>) {
<span class="hljs-keyword">if</span> (in.isOverfull()) {
splitInternalNode(in);
} <span class="hljs-keyword">else</span> {
<span class="hljs-keyword">break</span>;
}
in = in.parent;
}
}
}
}
}

<span class="hljs-function"><span class="hljs-keyword">public</span> Double <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>{

<span class="hljs-keyword">if</span> (isEmpty()) {
<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
}

LeafNode ln = (<span class="hljs-keyword">this</span>.root == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">this</span>.firstLeaf : findLeafNode(key);

DictionaryPair[] dps = ln.dictionary;
<span class="hljs-keyword">int</span> index = binarySearch(dps, ln.numPairs, key);

<span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) {
<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
} <span class="hljs-keyword">else</span> {
<span class="hljs-keyword">return</span> dps[index].value;
}
}

<span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Double&gt; <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lowerBound, <span class="hljs-keyword">int</span> upperBound)</span> </span>{

ArrayList&lt;Double&gt; values = <span class="hljs-keyword">new</span> ArrayList&lt;Double&gt;();

LeafNode currNode = <span class="hljs-keyword">this</span>.firstLeaf;
<span class="hljs-keyword">while</span> (currNode != <span class="hljs-keyword">null</span>) {

DictionaryPair dps[] = currNode.dictionary;
<span class="hljs-keyword">for</span> (DictionaryPair dp : dps) {

<span class="hljs-keyword">if</span> (dp == <span class="hljs-keyword">null</span>) {
<span class="hljs-keyword">break</span>;
}

<span class="hljs-keyword">if</span> (lowerBound &lt;= dp.key &amp;&amp; dp.key &lt;= upperBound) {
values.add(dp.value);
}
}
currNode = currNode.rightSibling;

}

<span class="hljs-keyword">return</span> values;
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BPlusTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m)</span> </span>{
<span class="hljs-keyword">this</span>.m = m;
<span class="hljs-keyword">this</span>.root = <span class="hljs-keyword">null</span>;
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>{
InternalNode parent;
}

<span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InternalNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span> </span>{
<span class="hljs-keyword">int</span> maxDegree;
<span class="hljs-keyword">int</span> minDegree;
<span class="hljs-keyword">int</span> degree;
InternalNode leftSibling;
InternalNode rightSibling;
Integer[] keys;
Node[] childPointers;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">appendChildPointer</span><span class="hljs-params">(Node pointer)</span> </span>{
<span class="hljs-keyword">this</span>.childPointers[degree] = pointer;
<span class="hljs-keyword">this</span>.degree++;
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findIndexOfPointer</span><span class="hljs-params">(Node pointer)</span> </span>{
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childPointers.length; i++) {
<span class="hljs-keyword">if</span> (childPointers[i] == pointer) {
<span class="hljs-keyword">return</span> i;
}
}
<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertChildPointer</span><span class="hljs-params">(Node pointer, <span class="hljs-keyword">int</span> index)</span> </span>{
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = degree - <span class="hljs-number">1</span>; i &gt;= index; i--) {
childPointers[i + <span class="hljs-number">1</span>] = childPointers[i];
}
<span class="hljs-keyword">this</span>.childPointers[index] = pointer;
<span class="hljs-keyword">this</span>.degree++;
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isDeficient</span><span class="hljs-params">()</span> </span>{
<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.degree &lt; <span class="hljs-keyword">this</span>.minDegree;
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLendable</span><span class="hljs-params">()</span> </span>{
<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.degree &gt; <span class="hljs-keyword">this</span>.minDegree;
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMergeable</span><span class="hljs-params">()</span> </span>{
<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.degree == <span class="hljs-keyword">this</span>.minDegree;
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOverfull</span><span class="hljs-params">()</span> </span>{
<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.degree == maxDegree + <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prependChildPointer</span><span class="hljs-params">(Node pointer)</span> </span>{
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = degree - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
childPointers[i + <span class="hljs-number">1</span>] = childPointers[i];
}
<span class="hljs-keyword">this</span>.childPointers[<span class="hljs-number">0</span>] = pointer;
<span class="hljs-keyword">this</span>.degree++;
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeKey</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>{
<span class="hljs-keyword">this</span>.keys[index] = <span class="hljs-keyword">null</span>;
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removePointer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>{
<span class="hljs-keyword">this</span>.childPointers[index] = <span class="hljs-keyword">null</span>;
<span class="hljs-keyword">this</span>.degree--;
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removePointer</span><span class="hljs-params">(Node pointer)</span> </span>{
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childPointers.length; i++) {
<span class="hljs-keyword">if</span> (childPointers[i] == pointer) {
<span class="hljs-keyword">this</span>.childPointers[i] = <span class="hljs-keyword">null</span>;
}
}
<span class="hljs-keyword">this</span>.degree--;
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">InternalNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, Integer[] keys)</span> </span>{
<span class="hljs-keyword">this</span>.maxDegree = m;
<span class="hljs-keyword">this</span>.minDegree = (<span class="hljs-keyword">int</span>) Math.ceil(m / <span class="hljs-number">2.0</span>);
<span class="hljs-keyword">this</span>.degree = <span class="hljs-number">0</span>;
<span class="hljs-keyword">this</span>.keys = keys;
<span class="hljs-keyword">this</span>.childPointers = <span class="hljs-keyword">new</span> Node[<span class="hljs-keyword">this</span>.maxDegree + <span class="hljs-number">1</span>];
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">InternalNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, Integer[] keys, Node[] pointers)</span> </span>{
<span class="hljs-keyword">this</span>.maxDegree = m;
<span class="hljs-keyword">this</span>.minDegree = (<span class="hljs-keyword">int</span>) Math.ceil(m / <span class="hljs-number">2.0</span>);
<span class="hljs-keyword">this</span>.degree = linearNullSearch(pointers);
<span class="hljs-keyword">this</span>.keys = keys;
<span class="hljs-keyword">this</span>.childPointers = pointers;
}
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeafNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span> </span>{
<span class="hljs-keyword">int</span> maxNumPairs;
<span class="hljs-keyword">int</span> minNumPairs;
<span class="hljs-keyword">int</span> numPairs;
LeafNode leftSibling;
LeafNode rightSibling;
DictionaryPair[] dictionary;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>{
<span class="hljs-keyword">this</span>.dictionary[index] = <span class="hljs-keyword">null</span>;
numPairs--;
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">insert</span><span class="hljs-params">(DictionaryPair dp)</span> </span>{
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isFull()) {
<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
} <span class="hljs-keyword">else</span> {
<span class="hljs-keyword">this</span>.dictionary[numPairs] = dp;
numPairs++;
Arrays.sort(<span class="hljs-keyword">this</span>.dictionary, <span class="hljs-number">0</span>, numPairs);

<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isDeficient</span><span class="hljs-params">()</span> </span>{
<span class="hljs-keyword">return</span> numPairs &lt; minNumPairs;
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>{
<span class="hljs-keyword">return</span> numPairs == maxNumPairs;
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLendable</span><span class="hljs-params">()</span> </span>{
<span class="hljs-keyword">return</span> numPairs &gt; minNumPairs;
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMergeable</span><span class="hljs-params">()</span> </span>{
<span class="hljs-keyword">return</span> numPairs == minNumPairs;
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LeafNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, DictionaryPair dp)</span> </span>{
<span class="hljs-keyword">this</span>.maxNumPairs = m - <span class="hljs-number">1</span>;
<span class="hljs-keyword">this</span>.minNumPairs = (<span class="hljs-keyword">int</span>) (Math.ceil(m / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>);
<span class="hljs-keyword">this</span>.dictionary = <span class="hljs-keyword">new</span> DictionaryPair[m];
<span class="hljs-keyword">this</span>.numPairs = <span class="hljs-number">0</span>;
<span class="hljs-keyword">this</span>.insert(dp);
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LeafNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, DictionaryPair[] dps, InternalNode parent)</span> </span>{
<span class="hljs-keyword">this</span>.maxNumPairs = m - <span class="hljs-number">1</span>;
<span class="hljs-keyword">this</span>.minNumPairs = (<span class="hljs-keyword">int</span>) (Math.ceil(m / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>);
<span class="hljs-keyword">this</span>.dictionary = dps;
<span class="hljs-keyword">this</span>.numPairs = linearNullSearch(dps);
<span class="hljs-keyword">this</span>.parent = parent;
}
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DictionaryPair</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">DictionaryPair</span>&gt; </span>{
<span class="hljs-keyword">int</span> key;
<span class="hljs-keyword">double</span> value;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DictionaryPair</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">double</span> value)</span> </span>{
<span class="hljs-keyword">this</span>.key = key;
<span class="hljs-keyword">this</span>.value = value;
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(DictionaryPair o)</span> </span>{
<span class="hljs-keyword">if</span> (key == o.key) {
<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; o.key) {
<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
} <span class="hljs-keyword">else</span> {
<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}
}
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
BPlusTree bpt = <span class="hljs-keyword">null</span>;
bpt = <span class="hljs-keyword">new</span> BPlusTree(<span class="hljs-number">3</span>);
bpt.insert(<span class="hljs-number">5</span>, <span class="hljs-number">33</span>);
bpt.insert(<span class="hljs-number">15</span>, <span class="hljs-number">21</span>);
bpt.insert(<span class="hljs-number">25</span>, <span class="hljs-number">31</span>);
bpt.insert(<span class="hljs-number">35</span>, <span class="hljs-number">41</span>);
bpt.insert(<span class="hljs-number">45</span>, <span class="hljs-number">10</span>);

<span class="hljs-keyword">if</span> (bpt.search(<span class="hljs-number">15</span>) != <span class="hljs-keyword">null</span>) {
System.out.println(<span class="hljs-string">"Found"</span>);
} <span class="hljs-keyword">else</span> {
System.out.println(<span class="hljs-string">"Not Found"</span>);
}
;
}
}</code></pre></div>
</div>

<div class="code-editor__area" id="c-code">
<div class="pre-code-wrapper"><div title="Click to copy" class="copy-code-button"></div><pre class="exec" style="max-height: 600px;"><code class="c hljs cpp"><span class="hljs-comment">// Deletion on a B+ Tree in C</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>

<span class="hljs-comment">// Default order</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ORDER 3</span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">record</span> {</span>
<span class="hljs-keyword">int</span> value;
} record;

<span class="hljs-comment">// Node</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> {</span>
<span class="hljs-keyword">void</span> **pointers;
<span class="hljs-keyword">int</span> *keys;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">parent</span>;</span>
<span class="hljs-keyword">bool</span> is_leaf;
<span class="hljs-keyword">int</span> num_keys;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span>
} node;

<span class="hljs-keyword">int</span> order = ORDER;
node *<span class="hljs-built_in">queue</span> = <span class="hljs-literal">NULL</span>;
<span class="hljs-keyword">bool</span> verbose_output = <span class="hljs-literal">false</span>;

<span class="hljs-comment">// Enqueue</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(node *new_node)</span></span>;

<span class="hljs-comment">// Dequeue</span>
<span class="hljs-function">node *<span class="hljs-title">dequeue</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">height</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pathToLeaves</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root, node *child)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printLeaves</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printTree</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findAndPrint</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root, <span class="hljs-keyword">int</span> key, <span class="hljs-keyword">bool</span> verbose)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findAndPrintRange</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root, <span class="hljs-keyword">int</span> range1, <span class="hljs-keyword">int</span> range2, <span class="hljs-keyword">bool</span> verbose)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRange</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root, <span class="hljs-keyword">int</span> key_start, <span class="hljs-keyword">int</span> key_end, <span class="hljs-keyword">bool</span> verbose,
<span class="hljs-keyword">int</span> returned_keys[], <span class="hljs-keyword">void</span> *returned_pointers[])</span></span>;
<span class="hljs-function">node *<span class="hljs-title">findLeaf</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root, <span class="hljs-keyword">int</span> key, <span class="hljs-keyword">bool</span> verbose)</span></span>;
<span class="hljs-function">record *<span class="hljs-title">find</span><span class="hljs-params">(node *root, <span class="hljs-keyword">int</span> key, <span class="hljs-keyword">bool</span> verbose, node **leaf_out)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cut</span><span class="hljs-params">(<span class="hljs-keyword">int</span> length)</span></span>;

<span class="hljs-function">record *<span class="hljs-title">makeRecord</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>;
<span class="hljs-function">node *<span class="hljs-title">makeNode</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;
<span class="hljs-function">node *<span class="hljs-title">makeLeaf</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getLeftIndex</span><span class="hljs-params">(node *parent, node *left)</span></span>;
<span class="hljs-function">node *<span class="hljs-title">insertIntoLeaf</span><span class="hljs-params">(node *leaf, <span class="hljs-keyword">int</span> key, record *pointer)</span></span>;
<span class="hljs-function">node *<span class="hljs-title">insertIntoLeafAfterSplitting</span><span class="hljs-params">(node *root, node *leaf, <span class="hljs-keyword">int</span> key,
record *pointer)</span></span>;
<span class="hljs-function">node *<span class="hljs-title">insertIntoNode</span><span class="hljs-params">(node *root, node *parent,
<span class="hljs-keyword">int</span> left_index, <span class="hljs-keyword">int</span> key, node *right)</span></span>;
<span class="hljs-function">node *<span class="hljs-title">insertIntoNodeAfterSplitting</span><span class="hljs-params">(node *root, node *parent,
<span class="hljs-keyword">int</span> left_index,
<span class="hljs-keyword">int</span> key, node *right)</span></span>;
<span class="hljs-function">node *<span class="hljs-title">insertIntoParent</span><span class="hljs-params">(node *root, node *left, <span class="hljs-keyword">int</span> key, node *right)</span></span>;
<span class="hljs-function">node *<span class="hljs-title">insertIntoNewRoot</span><span class="hljs-params">(node *left, <span class="hljs-keyword">int</span> key, node *right)</span></span>;
<span class="hljs-function">node *<span class="hljs-title">startNewTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, record *pointer)</span></span>;
<span class="hljs-function">node *<span class="hljs-title">insert</span><span class="hljs-params">(node *root, <span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span></span>;

<span class="hljs-comment">// Enqueue</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(node *new_node)</span> </span>{
node *c;
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">queue</span> == <span class="hljs-literal">NULL</span>) {
<span class="hljs-built_in">queue</span> = new_node;
<span class="hljs-built_in">queue</span>-&gt;next = <span class="hljs-literal">NULL</span>;
} <span class="hljs-keyword">else</span> {
c = <span class="hljs-built_in">queue</span>;
<span class="hljs-keyword">while</span> (c-&gt;next != <span class="hljs-literal">NULL</span>) {
c = c-&gt;next;
}
c-&gt;next = new_node;
new_node-&gt;next = <span class="hljs-literal">NULL</span>;
}
}

<span class="hljs-comment">// Dequeue</span>
<span class="hljs-function">node *<span class="hljs-title">dequeue</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
node *n = <span class="hljs-built_in">queue</span>;
<span class="hljs-built_in">queue</span> = <span class="hljs-built_in">queue</span>-&gt;next;
n-&gt;next = <span class="hljs-literal">NULL</span>;
<span class="hljs-keyword">return</span> n;
}

<span class="hljs-comment">// Print the leaves</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printLeaves</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root)</span> </span>{
<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) {
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Empty tree.\n"</span>);
<span class="hljs-keyword">return</span>;
}
<span class="hljs-keyword">int</span> i;
node *c = root;
<span class="hljs-keyword">while</span> (!c-&gt;is_leaf)
c = c-&gt;pointers[<span class="hljs-number">0</span>];
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; c-&gt;num_keys; i++) {
<span class="hljs-keyword">if</span> (verbose_output)
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%p "</span>, c-&gt;pointers[i]);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, c-&gt;keys[i]);
}
<span class="hljs-keyword">if</span> (verbose_output)
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%p "</span>, c-&gt;pointers[order - <span class="hljs-number">1</span>]);
<span class="hljs-keyword">if</span> (c-&gt;pointers[order - <span class="hljs-number">1</span>] != <span class="hljs-literal">NULL</span>) {
<span class="hljs-built_in">printf</span>(<span class="hljs-string">" | "</span>);
c = c-&gt;pointers[order - <span class="hljs-number">1</span>];
} <span class="hljs-keyword">else</span>
<span class="hljs-keyword">break</span>;
}
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}

<span class="hljs-comment">// Calculate height</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">height</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root)</span> </span>{
<span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>;
node *c = root;
<span class="hljs-keyword">while</span> (!c-&gt;is_leaf) {
c = c-&gt;pointers[<span class="hljs-number">0</span>];
h++;
}
<span class="hljs-keyword">return</span> h;
}

<span class="hljs-comment">// Get path to root</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pathToLeaves</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root, node *child)</span> </span>{
<span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;
node *c = child;
<span class="hljs-keyword">while</span> (c != root) {
c = c-&gt;parent;
length++;
}
<span class="hljs-keyword">return</span> length;
}

<span class="hljs-comment">// Print the tree</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printTree</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root)</span> </span>{
node *n = <span class="hljs-literal">NULL</span>;
<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> rank = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> new_rank = <span class="hljs-number">0</span>;

<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) {
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Empty tree.\n"</span>);
<span class="hljs-keyword">return</span>;
}
<span class="hljs-built_in">queue</span> = <span class="hljs-literal">NULL</span>;
enqueue(root);
<span class="hljs-keyword">while</span> (<span class="hljs-built_in">queue</span> != <span class="hljs-literal">NULL</span>) {
n = dequeue();
<span class="hljs-keyword">if</span> (n-&gt;parent != <span class="hljs-literal">NULL</span> &amp;&amp; n == n-&gt;parent-&gt;pointers[<span class="hljs-number">0</span>]) {
new_rank = pathToLeaves(root, n);
<span class="hljs-keyword">if</span> (new_rank != rank) {
rank = new_rank;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}
}
<span class="hljs-keyword">if</span> (verbose_output)
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"(%p)"</span>, n);
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n-&gt;num_keys; i++) {
<span class="hljs-keyword">if</span> (verbose_output)
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%p "</span>, n-&gt;pointers[i]);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, n-&gt;keys[i]);
}
<span class="hljs-keyword">if</span> (!n-&gt;is_leaf)
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= n-&gt;num_keys; i++)
enqueue(n-&gt;pointers[i]);
<span class="hljs-keyword">if</span> (verbose_output) {
<span class="hljs-keyword">if</span> (n-&gt;is_leaf)
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%p "</span>, n-&gt;pointers[order - <span class="hljs-number">1</span>]);
<span class="hljs-keyword">else</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%p "</span>, n-&gt;pointers[n-&gt;num_keys]);
}
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"| "</span>);
}
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}

<span class="hljs-comment">// Find the node and print it</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findAndPrint</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root, <span class="hljs-keyword">int</span> key, <span class="hljs-keyword">bool</span> verbose)</span> </span>{
node *leaf = <span class="hljs-literal">NULL</span>;
record *r = find(root, key, verbose, <span class="hljs-literal">NULL</span>);
<span class="hljs-keyword">if</span> (r == <span class="hljs-literal">NULL</span>)
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Record not found under key %d.\n"</span>, key);
<span class="hljs-keyword">else</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Record at %p -- key %d, value %d.\n"</span>,
r, key, r-&gt;value);
}

<span class="hljs-comment">// Find and print the range</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findAndPrintRange</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root, <span class="hljs-keyword">int</span> key_start, <span class="hljs-keyword">int</span> key_end,
<span class="hljs-keyword">bool</span> verbose)</span> </span>{
<span class="hljs-keyword">int</span> i;
<span class="hljs-keyword">int</span> array_size = key_end - key_start + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> returned_keys[array_size];
<span class="hljs-keyword">void</span> *returned_pointers[array_size];
<span class="hljs-keyword">int</span> num_found = findRange(root, key_start, key_end, verbose,
returned_keys, returned_pointers);
<span class="hljs-keyword">if</span> (!num_found)
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"None found.\n"</span>);
<span class="hljs-keyword">else</span> {
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_found; i++)
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Key: %d   Location: %p  Value: %d\n"</span>,
returned_keys[i],
returned_pointers[i],
((record *)
returned_pointers[i])
-&gt;value);
}
}

<span class="hljs-comment">// Find the range</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRange</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root, <span class="hljs-keyword">int</span> key_start, <span class="hljs-keyword">int</span> key_end, <span class="hljs-keyword">bool</span> verbose,
<span class="hljs-keyword">int</span> returned_keys[], <span class="hljs-keyword">void</span> *returned_pointers[])</span> </span>{
<span class="hljs-keyword">int</span> i, num_found;
num_found = <span class="hljs-number">0</span>;
node *n = findLeaf(root, key_start, verbose);
<span class="hljs-keyword">if</span> (n == <span class="hljs-literal">NULL</span>)
<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n-&gt;num_keys &amp;&amp; n-&gt;keys[i] &lt; key_start; i++)
;
<span class="hljs-keyword">if</span> (i == n-&gt;num_keys)
<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (n != <span class="hljs-literal">NULL</span>) {
<span class="hljs-keyword">for</span> (; i &lt; n-&gt;num_keys &amp;&amp; n-&gt;keys[i] &lt;= key_end; i++) {
returned_keys[num_found] = n-&gt;keys[i];
returned_pointers[num_found] = n-&gt;pointers[i];
num_found++;
}
n = n-&gt;pointers[order - <span class="hljs-number">1</span>];
i = <span class="hljs-number">0</span>;
}
<span class="hljs-keyword">return</span> num_found;
}

<span class="hljs-comment">// Find the leaf</span>
<span class="hljs-function">node *<span class="hljs-title">findLeaf</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root, <span class="hljs-keyword">int</span> key, <span class="hljs-keyword">bool</span> verbose)</span> </span>{
<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) {
<span class="hljs-keyword">if</span> (verbose)
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Empty tree.\n"</span>);
<span class="hljs-keyword">return</span> root;
}
<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
node *c = root;
<span class="hljs-keyword">while</span> (!c-&gt;is_leaf) {
<span class="hljs-keyword">if</span> (verbose) {
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"["</span>);
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; c-&gt;num_keys - <span class="hljs-number">1</span>; i++)
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, c-&gt;keys[i]);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d] "</span>, c-&gt;keys[i]);
}
i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (i &lt; c-&gt;num_keys) {
<span class="hljs-keyword">if</span> (key &gt;= c-&gt;keys[i])
i++;
<span class="hljs-keyword">else</span>
<span class="hljs-keyword">break</span>;
}
<span class="hljs-keyword">if</span> (verbose)
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d -&gt;\n"</span>, i);
c = (node *)c-&gt;pointers[i];
}
<span class="hljs-keyword">if</span> (verbose) {
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Leaf ["</span>);
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; c-&gt;num_keys - <span class="hljs-number">1</span>; i++)
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, c-&gt;keys[i]);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d] -&gt;\n"</span>, c-&gt;keys[i]);
}
<span class="hljs-keyword">return</span> c;
}

<span class="hljs-function">record *<span class="hljs-title">find</span><span class="hljs-params">(node *root, <span class="hljs-keyword">int</span> key, <span class="hljs-keyword">bool</span> verbose, node **leaf_out)</span> </span>{
<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) {
<span class="hljs-keyword">if</span> (leaf_out != <span class="hljs-literal">NULL</span>) {
*leaf_out = <span class="hljs-literal">NULL</span>;
}
<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
}

<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
node *leaf = <span class="hljs-literal">NULL</span>;

leaf = findLeaf(root, key, verbose);

<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; leaf-&gt;num_keys; i++)
<span class="hljs-keyword">if</span> (leaf-&gt;keys[i] == key)
<span class="hljs-keyword">break</span>;
<span class="hljs-keyword">if</span> (leaf_out != <span class="hljs-literal">NULL</span>) {
*leaf_out = leaf;
}
<span class="hljs-keyword">if</span> (i == leaf-&gt;num_keys)
<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
<span class="hljs-keyword">else</span>
<span class="hljs-keyword">return</span> (record *)leaf-&gt;pointers[i];
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cut</span><span class="hljs-params">(<span class="hljs-keyword">int</span> length)</span> </span>{
<span class="hljs-keyword">if</span> (length % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)
<span class="hljs-keyword">return</span> length / <span class="hljs-number">2</span>;
<span class="hljs-keyword">else</span>
<span class="hljs-keyword">return</span> length / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
}

<span class="hljs-function">record *<span class="hljs-title">makeRecord</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>{
record *new_record = (record *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(record));
<span class="hljs-keyword">if</span> (new_record == <span class="hljs-literal">NULL</span>) {
perror(<span class="hljs-string">"Record creation."</span>);
<span class="hljs-built_in">exit</span>(EXIT_FAILURE);
} <span class="hljs-keyword">else</span> {
new_record-&gt;value = value;
}
<span class="hljs-keyword">return</span> new_record;
}

<span class="hljs-function">node *<span class="hljs-title">makeNode</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
node *new_node;
new_node = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));
<span class="hljs-keyword">if</span> (new_node == <span class="hljs-literal">NULL</span>) {
perror(<span class="hljs-string">"Node creation."</span>);
<span class="hljs-built_in">exit</span>(EXIT_FAILURE);
}
new_node-&gt;keys = <span class="hljs-built_in">malloc</span>((order - <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
<span class="hljs-keyword">if</span> (new_node-&gt;keys == <span class="hljs-literal">NULL</span>) {
perror(<span class="hljs-string">"New node keys array."</span>);
<span class="hljs-built_in">exit</span>(EXIT_FAILURE);
}
new_node-&gt;pointers = <span class="hljs-built_in">malloc</span>(order * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">void</span> *));
<span class="hljs-keyword">if</span> (new_node-&gt;pointers == <span class="hljs-literal">NULL</span>) {
perror(<span class="hljs-string">"New node pointers array."</span>);
<span class="hljs-built_in">exit</span>(EXIT_FAILURE);
}
new_node-&gt;is_leaf = <span class="hljs-literal">false</span>;
new_node-&gt;num_keys = <span class="hljs-number">0</span>;
new_node-&gt;parent = <span class="hljs-literal">NULL</span>;
new_node-&gt;next = <span class="hljs-literal">NULL</span>;
<span class="hljs-keyword">return</span> new_node;
}

<span class="hljs-function">node *<span class="hljs-title">makeLeaf</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
node *leaf = makeNode();
leaf-&gt;is_leaf = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">return</span> leaf;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getLeftIndex</span><span class="hljs-params">(node *parent, node *left)</span> </span>{
<span class="hljs-keyword">int</span> left_index = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (left_index &lt;= parent-&gt;num_keys &amp;&amp;
parent-&gt;pointers[left_index] != left)
left_index++;
<span class="hljs-keyword">return</span> left_index;
}

<span class="hljs-function">node *<span class="hljs-title">insertIntoLeaf</span><span class="hljs-params">(node *leaf, <span class="hljs-keyword">int</span> key, record *pointer)</span> </span>{
<span class="hljs-keyword">int</span> i, insertion_point;

insertion_point = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (insertion_point &lt; leaf-&gt;num_keys &amp;&amp; leaf-&gt;keys[insertion_point] &lt; key)
insertion_point++;

<span class="hljs-keyword">for</span> (i = leaf-&gt;num_keys; i &gt; insertion_point; i--) {
leaf-&gt;keys[i] = leaf-&gt;keys[i - <span class="hljs-number">1</span>];
leaf-&gt;pointers[i] = leaf-&gt;pointers[i - <span class="hljs-number">1</span>];
}
leaf-&gt;keys[insertion_point] = key;
leaf-&gt;pointers[insertion_point] = pointer;
leaf-&gt;num_keys++;
<span class="hljs-keyword">return</span> leaf;
}

<span class="hljs-function">node *<span class="hljs-title">insertIntoLeafAfterSplitting</span><span class="hljs-params">(node *root, node *leaf, <span class="hljs-keyword">int</span> key, record *pointer)</span> </span>{
node *new_leaf;
<span class="hljs-keyword">int</span> *temp_keys;
<span class="hljs-keyword">void</span> **temp_pointers;
<span class="hljs-keyword">int</span> insertion_index, split, new_key, i, j;

new_leaf = makeLeaf();

temp_keys = <span class="hljs-built_in">malloc</span>(order * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
<span class="hljs-keyword">if</span> (temp_keys == <span class="hljs-literal">NULL</span>) {
perror(<span class="hljs-string">"Temporary keys array."</span>);
<span class="hljs-built_in">exit</span>(EXIT_FAILURE);
}

temp_pointers = <span class="hljs-built_in">malloc</span>(order * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">void</span> *));
<span class="hljs-keyword">if</span> (temp_pointers == <span class="hljs-literal">NULL</span>) {
perror(<span class="hljs-string">"Temporary pointers array."</span>);
<span class="hljs-built_in">exit</span>(EXIT_FAILURE);
}

insertion_index = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (insertion_index &lt; order - <span class="hljs-number">1</span> &amp;&amp; leaf-&gt;keys[insertion_index] &lt; key)
insertion_index++;

<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; leaf-&gt;num_keys; i++, j++) {
<span class="hljs-keyword">if</span> (j == insertion_index)
j++;
temp_keys[j] = leaf-&gt;keys[i];
temp_pointers[j] = leaf-&gt;pointers[i];
}

temp_keys[insertion_index] = key;
temp_pointers[insertion_index] = pointer;

leaf-&gt;num_keys = <span class="hljs-number">0</span>;

split = cut(order - <span class="hljs-number">1</span>);

<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; split; i++) {
leaf-&gt;pointers[i] = temp_pointers[i];
leaf-&gt;keys[i] = temp_keys[i];
leaf-&gt;num_keys++;
}

<span class="hljs-keyword">for</span> (i = split, j = <span class="hljs-number">0</span>; i &lt; order; i++, j++) {
new_leaf-&gt;pointers[j] = temp_pointers[i];
new_leaf-&gt;keys[j] = temp_keys[i];
new_leaf-&gt;num_keys++;
}

<span class="hljs-built_in">free</span>(temp_pointers);
<span class="hljs-built_in">free</span>(temp_keys);

new_leaf-&gt;pointers[order - <span class="hljs-number">1</span>] = leaf-&gt;pointers[order - <span class="hljs-number">1</span>];
leaf-&gt;pointers[order - <span class="hljs-number">1</span>] = new_leaf;

<span class="hljs-keyword">for</span> (i = leaf-&gt;num_keys; i &lt; order - <span class="hljs-number">1</span>; i++)
leaf-&gt;pointers[i] = <span class="hljs-literal">NULL</span>;
<span class="hljs-keyword">for</span> (i = new_leaf-&gt;num_keys; i &lt; order - <span class="hljs-number">1</span>; i++)
new_leaf-&gt;pointers[i] = <span class="hljs-literal">NULL</span>;

new_leaf-&gt;parent = leaf-&gt;parent;
new_key = new_leaf-&gt;keys[<span class="hljs-number">0</span>];

<span class="hljs-keyword">return</span> insertIntoParent(root, leaf, new_key, new_leaf);
}

<span class="hljs-function">node *<span class="hljs-title">insertIntoNode</span><span class="hljs-params">(node *root, node *n,
<span class="hljs-keyword">int</span> left_index, <span class="hljs-keyword">int</span> key, node *right)</span> </span>{
<span class="hljs-keyword">int</span> i;

<span class="hljs-keyword">for</span> (i = n-&gt;num_keys; i &gt; left_index; i--) {
n-&gt;pointers[i + <span class="hljs-number">1</span>] = n-&gt;pointers[i];
n-&gt;keys[i] = n-&gt;keys[i - <span class="hljs-number">1</span>];
}
n-&gt;pointers[left_index + <span class="hljs-number">1</span>] = right;
n-&gt;keys[left_index] = key;
n-&gt;num_keys++;
<span class="hljs-keyword">return</span> root;
}

<span class="hljs-function">node *<span class="hljs-title">insertIntoNodeAfterSplitting</span><span class="hljs-params">(node *root, node *old_node, <span class="hljs-keyword">int</span> left_index,
<span class="hljs-keyword">int</span> key, node *right)</span> </span>{
<span class="hljs-keyword">int</span> i, j, split, k_prime;
node *new_node, *child;
<span class="hljs-keyword">int</span> *temp_keys;
node **temp_pointers;

temp_pointers = <span class="hljs-built_in">malloc</span>((order + <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(node *));
<span class="hljs-keyword">if</span> (temp_pointers == <span class="hljs-literal">NULL</span>) {
<span class="hljs-built_in">exit</span>(EXIT_FAILURE);
}
temp_keys = <span class="hljs-built_in">malloc</span>(order * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
<span class="hljs-keyword">if</span> (temp_keys == <span class="hljs-literal">NULL</span>) {
<span class="hljs-built_in">exit</span>(EXIT_FAILURE);
}

<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; old_node-&gt;num_keys + <span class="hljs-number">1</span>; i++, j++) {
<span class="hljs-keyword">if</span> (j == left_index + <span class="hljs-number">1</span>)
j++;
temp_pointers[j] = old_node-&gt;pointers[i];
}

<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; old_node-&gt;num_keys; i++, j++) {
<span class="hljs-keyword">if</span> (j == left_index)
j++;
temp_keys[j] = old_node-&gt;keys[i];
}

temp_pointers[left_index + <span class="hljs-number">1</span>] = right;
temp_keys[left_index] = key;

split = cut(order);
new_node = makeNode();
old_node-&gt;num_keys = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; split - <span class="hljs-number">1</span>; i++) {
old_node-&gt;pointers[i] = temp_pointers[i];
old_node-&gt;keys[i] = temp_keys[i];
old_node-&gt;num_keys++;
}
old_node-&gt;pointers[i] = temp_pointers[i];
k_prime = temp_keys[split - <span class="hljs-number">1</span>];
<span class="hljs-keyword">for</span> (++i, j = <span class="hljs-number">0</span>; i &lt; order; i++, j++) {
new_node-&gt;pointers[j] = temp_pointers[i];
new_node-&gt;keys[j] = temp_keys[i];
new_node-&gt;num_keys++;
}
new_node-&gt;pointers[j] = temp_pointers[i];
<span class="hljs-built_in">free</span>(temp_pointers);
<span class="hljs-built_in">free</span>(temp_keys);
new_node-&gt;parent = old_node-&gt;parent;
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= new_node-&gt;num_keys; i++) {
child = new_node-&gt;pointers[i];
child-&gt;parent = new_node;
}

<span class="hljs-keyword">return</span> insertIntoParent(root, old_node, k_prime, new_node);
}

<span class="hljs-function">node *<span class="hljs-title">insertIntoParent</span><span class="hljs-params">(node *root, node *left, <span class="hljs-keyword">int</span> key, node *right)</span> </span>{
<span class="hljs-keyword">int</span> left_index;
node *parent;

parent = left-&gt;parent;

<span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">NULL</span>)
<span class="hljs-keyword">return</span> insertIntoNewRoot(left, key, right);

left_index = getLeftIndex(parent, left);

<span class="hljs-keyword">if</span> (parent-&gt;num_keys &lt; order - <span class="hljs-number">1</span>)
<span class="hljs-keyword">return</span> insertIntoNode(root, parent, left_index, key, right);

<span class="hljs-keyword">return</span> insertIntoNodeAfterSplitting(root, parent, left_index, key, right);
}

<span class="hljs-function">node *<span class="hljs-title">insertIntoNewRoot</span><span class="hljs-params">(node *left, <span class="hljs-keyword">int</span> key, node *right)</span> </span>{
node *root = makeNode();
root-&gt;keys[<span class="hljs-number">0</span>] = key;
root-&gt;pointers[<span class="hljs-number">0</span>] = left;
root-&gt;pointers[<span class="hljs-number">1</span>] = right;
root-&gt;num_keys++;
root-&gt;parent = <span class="hljs-literal">NULL</span>;
left-&gt;parent = root;
right-&gt;parent = root;
<span class="hljs-keyword">return</span> root;
}

<span class="hljs-function">node *<span class="hljs-title">startNewTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, record *pointer)</span> </span>{
node *root = makeLeaf();
root-&gt;keys[<span class="hljs-number">0</span>] = key;
root-&gt;pointers[<span class="hljs-number">0</span>] = pointer;
root-&gt;pointers[order - <span class="hljs-number">1</span>] = <span class="hljs-literal">NULL</span>;
root-&gt;parent = <span class="hljs-literal">NULL</span>;
root-&gt;num_keys++;
<span class="hljs-keyword">return</span> root;
}

<span class="hljs-function">node *<span class="hljs-title">insert</span><span class="hljs-params">(node *root, <span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>{
record *record_pointer = <span class="hljs-literal">NULL</span>;
node *leaf = <span class="hljs-literal">NULL</span>;

record_pointer = find(root, key, <span class="hljs-literal">false</span>, <span class="hljs-literal">NULL</span>);
<span class="hljs-keyword">if</span> (record_pointer != <span class="hljs-literal">NULL</span>) {
record_pointer-&gt;value = value;
<span class="hljs-keyword">return</span> root;
}

record_pointer = makeRecord(value);

<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)
<span class="hljs-keyword">return</span> startNewTree(key, record_pointer);

leaf = findLeaf(root, key, <span class="hljs-literal">false</span>);

<span class="hljs-keyword">if</span> (leaf-&gt;num_keys &lt; order - <span class="hljs-number">1</span>) {
leaf = insertIntoLeaf(leaf, key, record_pointer);
<span class="hljs-keyword">return</span> root;
}

<span class="hljs-keyword">return</span> insertIntoLeafAfterSplitting(root, leaf, key, record_pointer);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
node *root;
<span class="hljs-keyword">char</span> instruction;

root = <span class="hljs-literal">NULL</span>;

root = insert(root, <span class="hljs-number">5</span>, <span class="hljs-number">33</span>);
root = insert(root, <span class="hljs-number">15</span>, <span class="hljs-number">21</span>);
root = insert(root, <span class="hljs-number">25</span>, <span class="hljs-number">31</span>);
root = insert(root, <span class="hljs-number">35</span>, <span class="hljs-number">41</span>);
root = insert(root, <span class="hljs-number">45</span>, <span class="hljs-number">10</span>);

printTree(root);

findAndPrint(root, <span class="hljs-number">15</span>, instruction = <span class="hljs-string">'a'</span>);
}</code></pre></div>
</div>

<div class="code-editor__area" id="cpp-code">
<div class="pre-code-wrapper"><div title="Click to copy" class="copy-code-button"></div><pre class="exec" style="max-height: 600px;"><code class="cpp hljs"><span class="hljs-comment">// Deletion operation on a B+ Tree in C++</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEFAULT_ORDER 3</span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">record</span> {</span>
<span class="hljs-keyword">int</span> value;
} record;

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> {</span>
<span class="hljs-keyword">void</span> **pointers;
<span class="hljs-keyword">int</span> *keys;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">parent</span>;</span>
<span class="hljs-keyword">bool</span> is_leaf;
<span class="hljs-keyword">int</span> num_keys;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span>
} node;

<span class="hljs-keyword">int</span> order = DEFAULT_ORDER;
node *<span class="hljs-built_in">queue</span> = <span class="hljs-literal">NULL</span>;
<span class="hljs-keyword">bool</span> verbose_output = <span class="hljs-literal">false</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(node *new_node)</span></span>;
<span class="hljs-function">node *<span class="hljs-title">dequeue</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">height</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">path_to_root</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root, node *child)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_leaves</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_tree</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">find_and_print</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root, <span class="hljs-keyword">int</span> key, <span class="hljs-keyword">bool</span> verbose)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">find_and_print_range</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root, <span class="hljs-keyword">int</span> range1, <span class="hljs-keyword">int</span> range2, <span class="hljs-keyword">bool</span> verbose)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find_range</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root, <span class="hljs-keyword">int</span> key_start, <span class="hljs-keyword">int</span> key_end, <span class="hljs-keyword">bool</span> verbose,
<span class="hljs-keyword">int</span> returned_keys[], <span class="hljs-keyword">void</span> *returned_pointers[])</span></span>;
<span class="hljs-function">node *<span class="hljs-title">find_leaf</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root, <span class="hljs-keyword">int</span> key, <span class="hljs-keyword">bool</span> verbose)</span></span>;
<span class="hljs-function">record *<span class="hljs-title">find</span><span class="hljs-params">(node *root, <span class="hljs-keyword">int</span> key, <span class="hljs-keyword">bool</span> verbose, node **leaf_out)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cut</span><span class="hljs-params">(<span class="hljs-keyword">int</span> length)</span></span>;

<span class="hljs-function">record *<span class="hljs-title">make_record</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>;
<span class="hljs-function">node *<span class="hljs-title">make_node</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;
<span class="hljs-function">node *<span class="hljs-title">make_leaf</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_left_index</span><span class="hljs-params">(node *parent, node *left)</span></span>;
<span class="hljs-function">node *<span class="hljs-title">insert_into_leaf</span><span class="hljs-params">(node *leaf, <span class="hljs-keyword">int</span> key, record *pointer)</span></span>;
<span class="hljs-function">node *<span class="hljs-title">insert_into_leaf_after_splitting</span><span class="hljs-params">(node *root, node *leaf, <span class="hljs-keyword">int</span> key,
record *pointer)</span></span>;
<span class="hljs-function">node *<span class="hljs-title">insert_into_node</span><span class="hljs-params">(node *root, node *parent,
<span class="hljs-keyword">int</span> left_index, <span class="hljs-keyword">int</span> key, node *right)</span></span>;
<span class="hljs-function">node *<span class="hljs-title">insert_into_node_after_splitting</span><span class="hljs-params">(node *root, node *parent,
<span class="hljs-keyword">int</span> left_index,
<span class="hljs-keyword">int</span> key, node *right)</span></span>;
<span class="hljs-function">node *<span class="hljs-title">insert_into_parent</span><span class="hljs-params">(node *root, node *left, <span class="hljs-keyword">int</span> key, node *right)</span></span>;
<span class="hljs-function">node *<span class="hljs-title">insert_into_new_root</span><span class="hljs-params">(node *left, <span class="hljs-keyword">int</span> key, node *right)</span></span>;
<span class="hljs-function">node *<span class="hljs-title">start_new_tree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, record *pointer)</span></span>;
<span class="hljs-function">node *<span class="hljs-title">insert</span><span class="hljs-params">(node *root, <span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_neighbor_index</span><span class="hljs-params">(node *n)</span></span>;
<span class="hljs-function">node *<span class="hljs-title">adjust_root</span><span class="hljs-params">(node *root)</span></span>;
<span class="hljs-function">node *<span class="hljs-title">coalesce_nodes</span><span class="hljs-params">(node *root, node *n, node *neighbor,
<span class="hljs-keyword">int</span> neighbor_index, <span class="hljs-keyword">int</span> k_prime)</span></span>;
<span class="hljs-function">node *<span class="hljs-title">redistribute_nodes</span><span class="hljs-params">(node *root, node *n, node *neighbor,
<span class="hljs-keyword">int</span> neighbor_index,
<span class="hljs-keyword">int</span> k_prime_index, <span class="hljs-keyword">int</span> k_prime)</span></span>;
<span class="hljs-function">node *<span class="hljs-title">delete_entry</span><span class="hljs-params">(node *root, node *n, <span class="hljs-keyword">int</span> key, <span class="hljs-keyword">void</span> *pointer)</span></span>;
<span class="hljs-function">node *<span class="hljs-title">delete</span> <span class="hljs-params">(node *root, <span class="hljs-keyword">int</span> key)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(node *new_node)</span> </span>{
node *c;
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">queue</span> == <span class="hljs-literal">NULL</span>) {
<span class="hljs-built_in">queue</span> = new_node;
<span class="hljs-built_in">queue</span>-&gt;next = <span class="hljs-literal">NULL</span>;
} <span class="hljs-keyword">else</span> {
c = <span class="hljs-built_in">queue</span>;
<span class="hljs-keyword">while</span> (c-&gt;next != <span class="hljs-literal">NULL</span>) {
c = c-&gt;next;
}
c-&gt;next = new_node;
new_node-&gt;next = <span class="hljs-literal">NULL</span>;
}
}

<span class="hljs-function">node *<span class="hljs-title">dequeue</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
node *n = <span class="hljs-built_in">queue</span>;
<span class="hljs-built_in">queue</span> = <span class="hljs-built_in">queue</span>-&gt;next;
n-&gt;next = <span class="hljs-literal">NULL</span>;
<span class="hljs-keyword">return</span> n;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_leaves</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root)</span> </span>{
<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) {
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Empty tree.\n"</span>);
<span class="hljs-keyword">return</span>;
}
<span class="hljs-keyword">int</span> i;
node *c = root;
<span class="hljs-keyword">while</span> (!c-&gt;is_leaf)
c = c-&gt;pointers[<span class="hljs-number">0</span>];
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; c-&gt;num_keys; i++) {
<span class="hljs-keyword">if</span> (verbose_output)
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%p "</span>, c-&gt;pointers[i]);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, c-&gt;keys[i]);
}
<span class="hljs-keyword">if</span> (verbose_output)
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%p "</span>, c-&gt;pointers[order - <span class="hljs-number">1</span>]);
<span class="hljs-keyword">if</span> (c-&gt;pointers[order - <span class="hljs-number">1</span>] != <span class="hljs-literal">NULL</span>) {
<span class="hljs-built_in">printf</span>(<span class="hljs-string">" | "</span>);
c = c-&gt;pointers[order - <span class="hljs-number">1</span>];
} <span class="hljs-keyword">else</span>
<span class="hljs-keyword">break</span>;
}
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">height</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root)</span> </span>{
<span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>;
node *c = root;
<span class="hljs-keyword">while</span> (!c-&gt;is_leaf) {
c = c-&gt;pointers[<span class="hljs-number">0</span>];
h++;
}
<span class="hljs-keyword">return</span> h;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">path_to_root</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root, node *child)</span> </span>{
<span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;
node *c = child;
<span class="hljs-keyword">while</span> (c != root) {
c = c-&gt;parent;
length++;
}
<span class="hljs-keyword">return</span> length;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_tree</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root)</span> </span>{
node *n = <span class="hljs-literal">NULL</span>;
<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> rank = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> new_rank = <span class="hljs-number">0</span>;

<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) {
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Empty tree.\n"</span>);
<span class="hljs-keyword">return</span>;
}
<span class="hljs-built_in">queue</span> = <span class="hljs-literal">NULL</span>;
enqueue(root);
<span class="hljs-keyword">while</span> (<span class="hljs-built_in">queue</span> != <span class="hljs-literal">NULL</span>) {
n = dequeue();
<span class="hljs-keyword">if</span> (n-&gt;parent != <span class="hljs-literal">NULL</span> &amp;&amp; n == n-&gt;parent-&gt;pointers[<span class="hljs-number">0</span>]) {
new_rank = path_to_root(root, n);
<span class="hljs-keyword">if</span> (new_rank != rank) {
rank = new_rank;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}
}
<span class="hljs-keyword">if</span> (verbose_output)
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"(%p)"</span>, n);
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n-&gt;num_keys; i++) {
<span class="hljs-keyword">if</span> (verbose_output)
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%p "</span>, n-&gt;pointers[i]);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, n-&gt;keys[i]);
}
<span class="hljs-keyword">if</span> (!n-&gt;is_leaf)
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= n-&gt;num_keys; i++)
enqueue(n-&gt;pointers[i]);
<span class="hljs-keyword">if</span> (verbose_output) {
<span class="hljs-keyword">if</span> (n-&gt;is_leaf)
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%p "</span>, n-&gt;pointers[order - <span class="hljs-number">1</span>]);
<span class="hljs-keyword">else</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%p "</span>, n-&gt;pointers[n-&gt;num_keys]);
}
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"| "</span>);
}
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">find_and_print</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root, <span class="hljs-keyword">int</span> key, <span class="hljs-keyword">bool</span> verbose)</span> </span>{
node *leaf = <span class="hljs-literal">NULL</span>;
record *r = find(root, key, verbose, <span class="hljs-literal">NULL</span>);
<span class="hljs-keyword">if</span> (r == <span class="hljs-literal">NULL</span>)
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Record not found under key %d.\n"</span>, key);
<span class="hljs-keyword">else</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Record at %p -- key %d, value %d.\n"</span>,
r, key, r-&gt;value);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">find_and_print_range</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root, <span class="hljs-keyword">int</span> key_start, <span class="hljs-keyword">int</span> key_end,
<span class="hljs-keyword">bool</span> verbose)</span> </span>{
<span class="hljs-keyword">int</span> i;
<span class="hljs-keyword">int</span> array_size = key_end - key_start + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> returned_keys[array_size];
<span class="hljs-keyword">void</span> *returned_pointers[array_size];
<span class="hljs-keyword">int</span> num_found = find_range(root, key_start, key_end, verbose,
returned_keys, returned_pointers);
<span class="hljs-keyword">if</span> (!num_found)
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"None found.\n"</span>);
<span class="hljs-keyword">else</span> {
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_found; i++)
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Key: %d   Location: %p  Value: %d\n"</span>,
returned_keys[i],
returned_pointers[i],
((record *)
returned_pointers[i])
-&gt;value);
}
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find_range</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root, <span class="hljs-keyword">int</span> key_start, <span class="hljs-keyword">int</span> key_end, <span class="hljs-keyword">bool</span> verbose,
<span class="hljs-keyword">int</span> returned_keys[], <span class="hljs-keyword">void</span> *returned_pointers[])</span> </span>{
<span class="hljs-keyword">int</span> i, num_found;
num_found = <span class="hljs-number">0</span>;
node *n = find_leaf(root, key_start, verbose);
<span class="hljs-keyword">if</span> (n == <span class="hljs-literal">NULL</span>)
<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n-&gt;num_keys &amp;&amp; n-&gt;keys[i] &lt; key_start; i++)
;
<span class="hljs-keyword">if</span> (i == n-&gt;num_keys)
<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (n != <span class="hljs-literal">NULL</span>) {
<span class="hljs-keyword">for</span> (; i &lt; n-&gt;num_keys &amp;&amp; n-&gt;keys[i] &lt;= key_end; i++) {
returned_keys[num_found] = n-&gt;keys[i];
returned_pointers[num_found] = n-&gt;pointers[i];
num_found++;
}
n = n-&gt;pointers[order - <span class="hljs-number">1</span>];
i = <span class="hljs-number">0</span>;
}
<span class="hljs-keyword">return</span> num_found;
}

<span class="hljs-function">node *<span class="hljs-title">find_leaf</span><span class="hljs-params">(node *<span class="hljs-keyword">const</span> root, <span class="hljs-keyword">int</span> key, <span class="hljs-keyword">bool</span> verbose)</span> </span>{
<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) {
<span class="hljs-keyword">if</span> (verbose)
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Empty tree.\n"</span>);
<span class="hljs-keyword">return</span> root;
}
<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
node *c = root;
<span class="hljs-keyword">while</span> (!c-&gt;is_leaf) {
<span class="hljs-keyword">if</span> (verbose) {
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"["</span>);
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; c-&gt;num_keys - <span class="hljs-number">1</span>; i++)
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, c-&gt;keys[i]);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d] "</span>, c-&gt;keys[i]);
}
i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (i &lt; c-&gt;num_keys) {
<span class="hljs-keyword">if</span> (key &gt;= c-&gt;keys[i])
i++;
<span class="hljs-keyword">else</span>
<span class="hljs-keyword">break</span>;
}
<span class="hljs-keyword">if</span> (verbose)
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d -&gt;\n"</span>, i);
c = (node *)c-&gt;pointers[i];
}
<span class="hljs-keyword">if</span> (verbose) {
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Leaf ["</span>);
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; c-&gt;num_keys - <span class="hljs-number">1</span>; i++)
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, c-&gt;keys[i]);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d] -&gt;\n"</span>, c-&gt;keys[i]);
}
<span class="hljs-keyword">return</span> c;
}

<span class="hljs-function">record *<span class="hljs-title">find</span><span class="hljs-params">(node *root, <span class="hljs-keyword">int</span> key, <span class="hljs-keyword">bool</span> verbose, node **leaf_out)</span> </span>{
<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) {
<span class="hljs-keyword">if</span> (leaf_out != <span class="hljs-literal">NULL</span>) {
*leaf_out = <span class="hljs-literal">NULL</span>;
}
<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
}

<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
node *leaf = <span class="hljs-literal">NULL</span>;

leaf = find_leaf(root, key, verbose);

<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; leaf-&gt;num_keys; i++)
<span class="hljs-keyword">if</span> (leaf-&gt;keys[i] == key)
<span class="hljs-keyword">break</span>;
<span class="hljs-keyword">if</span> (leaf_out != <span class="hljs-literal">NULL</span>) {
*leaf_out = leaf;
}
<span class="hljs-keyword">if</span> (i == leaf-&gt;num_keys)
<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
<span class="hljs-keyword">else</span>
<span class="hljs-keyword">return</span> (record *)leaf-&gt;pointers[i];
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cut</span><span class="hljs-params">(<span class="hljs-keyword">int</span> length)</span> </span>{
<span class="hljs-keyword">if</span> (length % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)
<span class="hljs-keyword">return</span> length / <span class="hljs-number">2</span>;
<span class="hljs-keyword">else</span>
<span class="hljs-keyword">return</span> length / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
}

<span class="hljs-function">record *<span class="hljs-title">make_record</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>{
record *new_record = (record *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(record));
<span class="hljs-keyword">if</span> (new_record == <span class="hljs-literal">NULL</span>) {
perror(<span class="hljs-string">"Record creation."</span>);
<span class="hljs-built_in">exit</span>(EXIT_FAILURE);
} <span class="hljs-keyword">else</span> {
new_record-&gt;value = value;
}
<span class="hljs-keyword">return</span> new_record;
}

<span class="hljs-function">node *<span class="hljs-title">make_node</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
node *new_node;
new_node = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));
<span class="hljs-keyword">if</span> (new_node == <span class="hljs-literal">NULL</span>) {
perror(<span class="hljs-string">"Node creation."</span>);
<span class="hljs-built_in">exit</span>(EXIT_FAILURE);
}
new_node-&gt;keys = <span class="hljs-built_in">malloc</span>((order - <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
<span class="hljs-keyword">if</span> (new_node-&gt;keys == <span class="hljs-literal">NULL</span>) {
perror(<span class="hljs-string">"New node keys array."</span>);
<span class="hljs-built_in">exit</span>(EXIT_FAILURE);
}
new_node-&gt;pointers = <span class="hljs-built_in">malloc</span>(order * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">void</span> *));
<span class="hljs-keyword">if</span> (new_node-&gt;pointers == <span class="hljs-literal">NULL</span>) {
perror(<span class="hljs-string">"New node pointers array."</span>);
<span class="hljs-built_in">exit</span>(EXIT_FAILURE);
}
new_node-&gt;is_leaf = <span class="hljs-literal">false</span>;
new_node-&gt;num_keys = <span class="hljs-number">0</span>;
new_node-&gt;parent = <span class="hljs-literal">NULL</span>;
new_node-&gt;next = <span class="hljs-literal">NULL</span>;
<span class="hljs-keyword">return</span> new_node;
}

<span class="hljs-function">node *<span class="hljs-title">make_leaf</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
node *leaf = make_node();
leaf-&gt;is_leaf = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">return</span> leaf;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_left_index</span><span class="hljs-params">(node *parent, node *left)</span> </span>{
<span class="hljs-keyword">int</span> left_index = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (left_index &lt;= parent-&gt;num_keys &amp;&amp;
parent-&gt;pointers[left_index] != left)
left_index++;
<span class="hljs-keyword">return</span> left_index;
}

<span class="hljs-function">node *<span class="hljs-title">insert_into_leaf</span><span class="hljs-params">(node *leaf, <span class="hljs-keyword">int</span> key, record *pointer)</span> </span>{
<span class="hljs-keyword">int</span> i, insertion_point;

insertion_point = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (insertion_point &lt; leaf-&gt;num_keys &amp;&amp; leaf-&gt;keys[insertion_point] &lt; key)
insertion_point++;

<span class="hljs-keyword">for</span> (i = leaf-&gt;num_keys; i &gt; insertion_point; i--) {
leaf-&gt;keys[i] = leaf-&gt;keys[i - <span class="hljs-number">1</span>];
leaf-&gt;pointers[i] = leaf-&gt;pointers[i - <span class="hljs-number">1</span>];
}
leaf-&gt;keys[insertion_point] = key;
leaf-&gt;pointers[insertion_point] = pointer;
leaf-&gt;num_keys++;
<span class="hljs-keyword">return</span> leaf;
}

<span class="hljs-function">node *<span class="hljs-title">insert_into_leaf_after_splitting</span><span class="hljs-params">(node *root, node *leaf, <span class="hljs-keyword">int</span> key, record *pointer)</span> </span>{
node *new_leaf;
<span class="hljs-keyword">int</span> *temp_keys;
<span class="hljs-keyword">void</span> **temp_pointers;
<span class="hljs-keyword">int</span> insertion_index, split, new_key, i, j;

new_leaf = make_leaf();

temp_keys = <span class="hljs-built_in">malloc</span>(order * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
<span class="hljs-keyword">if</span> (temp_keys == <span class="hljs-literal">NULL</span>) {
perror(<span class="hljs-string">"Temporary keys array."</span>);
<span class="hljs-built_in">exit</span>(EXIT_FAILURE);
}

temp_pointers = <span class="hljs-built_in">malloc</span>(order * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">void</span> *));
<span class="hljs-keyword">if</span> (temp_pointers == <span class="hljs-literal">NULL</span>) {
perror(<span class="hljs-string">"Temporary pointers array."</span>);
<span class="hljs-built_in">exit</span>(EXIT_FAILURE);
}

insertion_index = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (insertion_index &lt; order - <span class="hljs-number">1</span> &amp;&amp; leaf-&gt;keys[insertion_index] &lt; key)
insertion_index++;

<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; leaf-&gt;num_keys; i++, j++) {
<span class="hljs-keyword">if</span> (j == insertion_index)
j++;
temp_keys[j] = leaf-&gt;keys[i];
temp_pointers[j] = leaf-&gt;pointers[i];
}

temp_keys[insertion_index] = key;
temp_pointers[insertion_index] = pointer;

leaf-&gt;num_keys = <span class="hljs-number">0</span>;

split = cut(order - <span class="hljs-number">1</span>);

<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; split; i++) {
leaf-&gt;pointers[i] = temp_pointers[i];
leaf-&gt;keys[i] = temp_keys[i];
leaf-&gt;num_keys++;
}

<span class="hljs-keyword">for</span> (i = split, j = <span class="hljs-number">0</span>; i &lt; order; i++, j++) {
new_leaf-&gt;pointers[j] = temp_pointers[i];
new_leaf-&gt;keys[j] = temp_keys[i];
new_leaf-&gt;num_keys++;
}

<span class="hljs-built_in">free</span>(temp_pointers);
<span class="hljs-built_in">free</span>(temp_keys);

new_leaf-&gt;pointers[order - <span class="hljs-number">1</span>] = leaf-&gt;pointers[order - <span class="hljs-number">1</span>];
leaf-&gt;pointers[order - <span class="hljs-number">1</span>] = new_leaf;

<span class="hljs-keyword">for</span> (i = leaf-&gt;num_keys; i &lt; order - <span class="hljs-number">1</span>; i++)
leaf-&gt;pointers[i] = <span class="hljs-literal">NULL</span>;
<span class="hljs-keyword">for</span> (i = new_leaf-&gt;num_keys; i &lt; order - <span class="hljs-number">1</span>; i++)
new_leaf-&gt;pointers[i] = <span class="hljs-literal">NULL</span>;

new_leaf-&gt;parent = leaf-&gt;parent;
new_key = new_leaf-&gt;keys[<span class="hljs-number">0</span>];

<span class="hljs-keyword">return</span> insert_into_parent(root, leaf, new_key, new_leaf);
}

<span class="hljs-function">node *<span class="hljs-title">insert_into_node</span><span class="hljs-params">(node *root, node *n,
<span class="hljs-keyword">int</span> left_index, <span class="hljs-keyword">int</span> key, node *right)</span> </span>{
<span class="hljs-keyword">int</span> i;

<span class="hljs-keyword">for</span> (i = n-&gt;num_keys; i &gt; left_index; i--) {
n-&gt;pointers[i + <span class="hljs-number">1</span>] = n-&gt;pointers[i];
n-&gt;keys[i] = n-&gt;keys[i - <span class="hljs-number">1</span>];
}
n-&gt;pointers[left_index + <span class="hljs-number">1</span>] = right;
n-&gt;keys[left_index] = key;
n-&gt;num_keys++;
<span class="hljs-keyword">return</span> root;
}

<span class="hljs-function">node *<span class="hljs-title">insert_into_node_after_splitting</span><span class="hljs-params">(node *root, node *old_node, <span class="hljs-keyword">int</span> left_index,
<span class="hljs-keyword">int</span> key, node *right)</span> </span>{
<span class="hljs-keyword">int</span> i, j, split, k_prime;
node *new_node, *child;
<span class="hljs-keyword">int</span> *temp_keys;
node **temp_pointers;

temp_pointers = <span class="hljs-built_in">malloc</span>((order + <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(node *));
<span class="hljs-keyword">if</span> (temp_pointers == <span class="hljs-literal">NULL</span>) {
perror(<span class="hljs-string">"Temporary pointers array for splitting nodes."</span>);
<span class="hljs-built_in">exit</span>(EXIT_FAILURE);
}
temp_keys = <span class="hljs-built_in">malloc</span>(order * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
<span class="hljs-keyword">if</span> (temp_keys == <span class="hljs-literal">NULL</span>) {
perror(<span class="hljs-string">"Temporary keys array for splitting nodes."</span>);
<span class="hljs-built_in">exit</span>(EXIT_FAILURE);
}

<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; old_node-&gt;num_keys + <span class="hljs-number">1</span>; i++, j++) {
<span class="hljs-keyword">if</span> (j == left_index + <span class="hljs-number">1</span>)
j++;
temp_pointers[j] = old_node-&gt;pointers[i];
}

<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; old_node-&gt;num_keys; i++, j++) {
<span class="hljs-keyword">if</span> (j == left_index)
j++;
temp_keys[j] = old_node-&gt;keys[i];
}

temp_pointers[left_index + <span class="hljs-number">1</span>] = right;
temp_keys[left_index] = key;

split = cut(order);
new_node = make_node();
old_node-&gt;num_keys = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; split - <span class="hljs-number">1</span>; i++) {
old_node-&gt;pointers[i] = temp_pointers[i];
old_node-&gt;keys[i] = temp_keys[i];
old_node-&gt;num_keys++;
}
old_node-&gt;pointers[i] = temp_pointers[i];
k_prime = temp_keys[split - <span class="hljs-number">1</span>];
<span class="hljs-keyword">for</span> (++i, j = <span class="hljs-number">0</span>; i &lt; order; i++, j++) {
new_node-&gt;pointers[j] = temp_pointers[i];
new_node-&gt;keys[j] = temp_keys[i];
new_node-&gt;num_keys++;
}
new_node-&gt;pointers[j] = temp_pointers[i];
<span class="hljs-built_in">free</span>(temp_pointers);
<span class="hljs-built_in">free</span>(temp_keys);
new_node-&gt;parent = old_node-&gt;parent;
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= new_node-&gt;num_keys; i++) {
child = new_node-&gt;pointers[i];
child-&gt;parent = new_node;
}

<span class="hljs-keyword">return</span> insert_into_parent(root, old_node, k_prime, new_node);
}

<span class="hljs-function">node *<span class="hljs-title">insert_into_parent</span><span class="hljs-params">(node *root, node *left, <span class="hljs-keyword">int</span> key, node *right)</span> </span>{
<span class="hljs-keyword">int</span> left_index;
node *parent;

parent = left-&gt;parent;

<span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">NULL</span>)
<span class="hljs-keyword">return</span> insert_into_new_root(left, key, right);

left_index = get_left_index(parent, left);

<span class="hljs-keyword">if</span> (parent-&gt;num_keys &lt; order - <span class="hljs-number">1</span>)
<span class="hljs-keyword">return</span> insert_into_node(root, parent, left_index, key, right);

<span class="hljs-keyword">return</span> insert_into_node_after_splitting(root, parent, left_index, key, right);
}

<span class="hljs-function">node *<span class="hljs-title">insert_into_new_root</span><span class="hljs-params">(node *left, <span class="hljs-keyword">int</span> key, node *right)</span> </span>{
node *root = make_node();
root-&gt;keys[<span class="hljs-number">0</span>] = key;
root-&gt;pointers[<span class="hljs-number">0</span>] = left;
root-&gt;pointers[<span class="hljs-number">1</span>] = right;
root-&gt;num_keys++;
root-&gt;parent = <span class="hljs-literal">NULL</span>;
left-&gt;parent = root;
right-&gt;parent = root;
<span class="hljs-keyword">return</span> root;
}

<span class="hljs-function">node *<span class="hljs-title">start_new_tree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, record *pointer)</span> </span>{
node *root = make_leaf();
root-&gt;keys[<span class="hljs-number">0</span>] = key;
root-&gt;pointers[<span class="hljs-number">0</span>] = pointer;
root-&gt;pointers[order - <span class="hljs-number">1</span>] = <span class="hljs-literal">NULL</span>;
root-&gt;parent = <span class="hljs-literal">NULL</span>;
root-&gt;num_keys++;
<span class="hljs-keyword">return</span> root;
}

<span class="hljs-function">node *<span class="hljs-title">insert</span><span class="hljs-params">(node *root, <span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>{
record *record_pointer = <span class="hljs-literal">NULL</span>;
node *leaf = <span class="hljs-literal">NULL</span>;

record_pointer = find(root, key, <span class="hljs-literal">false</span>, <span class="hljs-literal">NULL</span>);
<span class="hljs-keyword">if</span> (record_pointer != <span class="hljs-literal">NULL</span>) {
record_pointer-&gt;value = value;
<span class="hljs-keyword">return</span> root;
}

record_pointer = make_record(value);

<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)
<span class="hljs-keyword">return</span> start_new_tree(key, record_pointer);

leaf = find_leaf(root, key, <span class="hljs-literal">false</span>);

<span class="hljs-keyword">if</span> (leaf-&gt;num_keys &lt; order - <span class="hljs-number">1</span>) {
leaf = insert_into_leaf(leaf, key, record_pointer);
<span class="hljs-keyword">return</span> root;
}

<span class="hljs-keyword">return</span> insert_into_leaf_after_splitting(root, leaf, key, record_pointer);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_neighbor_index</span><span class="hljs-params">(node *n)</span> </span>{
<span class="hljs-keyword">int</span> i;
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= n-&gt;parent-&gt;num_keys; i++)
<span class="hljs-keyword">if</span> (n-&gt;parent-&gt;pointers[i] == n)
<span class="hljs-keyword">return</span> i - <span class="hljs-number">1</span>;

<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Search for nonexistent pointer to node in parent.\n"</span>);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Node:  %#lx\n"</span>, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)n);
<span class="hljs-built_in">exit</span>(EXIT_FAILURE);
}

<span class="hljs-function">node *<span class="hljs-title">remove_entry_from_node</span><span class="hljs-params">(node *n, <span class="hljs-keyword">int</span> key, node *pointer)</span> </span>{
<span class="hljs-keyword">int</span> i, num_pointers;
i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (n-&gt;keys[i] != key)
i++;
<span class="hljs-keyword">for</span> (++i; i &lt; n-&gt;num_keys; i++)
n-&gt;keys[i - <span class="hljs-number">1</span>] = n-&gt;keys[i];

num_pointers = n-&gt;is_leaf ? n-&gt;num_keys : n-&gt;num_keys + <span class="hljs-number">1</span>;
i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (n-&gt;pointers[i] != pointer)
i++;
<span class="hljs-keyword">for</span> (++i; i &lt; num_pointers; i++)
n-&gt;pointers[i - <span class="hljs-number">1</span>] = n-&gt;pointers[i];

n-&gt;num_keys--;

<span class="hljs-keyword">if</span> (n-&gt;is_leaf)
<span class="hljs-keyword">for</span> (i = n-&gt;num_keys; i &lt; order - <span class="hljs-number">1</span>; i++)
n-&gt;pointers[i] = <span class="hljs-literal">NULL</span>;
<span class="hljs-keyword">else</span>
<span class="hljs-keyword">for</span> (i = n-&gt;num_keys + <span class="hljs-number">1</span>; i &lt; order; i++)
n-&gt;pointers[i] = <span class="hljs-literal">NULL</span>;

<span class="hljs-keyword">return</span> n;
}

<span class="hljs-function">node *<span class="hljs-title">adjust_root</span><span class="hljs-params">(node *root)</span> </span>{
node *new_root;

<span class="hljs-keyword">if</span> (root-&gt;num_keys &gt; <span class="hljs-number">0</span>)
<span class="hljs-keyword">return</span> root;

<span class="hljs-keyword">if</span> (!root-&gt;is_leaf) {
new_root = root-&gt;pointers[<span class="hljs-number">0</span>];
new_root-&gt;parent = <span class="hljs-literal">NULL</span>;
}

<span class="hljs-keyword">else</span>
new_root = <span class="hljs-literal">NULL</span>;

<span class="hljs-built_in">free</span>(root-&gt;keys);
<span class="hljs-built_in">free</span>(root-&gt;pointers);
<span class="hljs-built_in">free</span>(root);

<span class="hljs-keyword">return</span> new_root;
}

<span class="hljs-function">node *<span class="hljs-title">coalesce_nodes</span><span class="hljs-params">(node *root, node *n, node *neighbor, <span class="hljs-keyword">int</span> neighbor_index, <span class="hljs-keyword">int</span> k_prime)</span> </span>{
<span class="hljs-keyword">int</span> i, j, neighbor_insertion_index, n_end;
node *tmp;

<span class="hljs-keyword">if</span> (neighbor_index == <span class="hljs-number">-1</span>) {
tmp = n;
n = neighbor;
neighbor = tmp;
}

neighbor_insertion_index = neighbor-&gt;num_keys;

<span class="hljs-keyword">if</span> (!n-&gt;is_leaf) {
neighbor-&gt;keys[neighbor_insertion_index] = k_prime;
neighbor-&gt;num_keys++;

n_end = n-&gt;num_keys;

<span class="hljs-keyword">for</span> (i = neighbor_insertion_index + <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; j &lt; n_end; i++, j++) {
neighbor-&gt;keys[i] = n-&gt;keys[j];
neighbor-&gt;pointers[i] = n-&gt;pointers[j];
neighbor-&gt;num_keys++;
n-&gt;num_keys--;
}

neighbor-&gt;pointers[i] = n-&gt;pointers[j];

<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; neighbor-&gt;num_keys + <span class="hljs-number">1</span>; i++) {
tmp = (node *)neighbor-&gt;pointers[i];
tmp-&gt;parent = neighbor;
}
}

<span class="hljs-keyword">else</span> {
<span class="hljs-keyword">for</span> (i = neighbor_insertion_index, j = <span class="hljs-number">0</span>; j &lt; n-&gt;num_keys; i++, j++) {
neighbor-&gt;keys[i] = n-&gt;keys[j];
neighbor-&gt;pointers[i] = n-&gt;pointers[j];
neighbor-&gt;num_keys++;
}
neighbor-&gt;pointers[order - <span class="hljs-number">1</span>] = n-&gt;pointers[order - <span class="hljs-number">1</span>];
}

root = delete_entry(root, n-&gt;parent, k_prime, n);
<span class="hljs-built_in">free</span>(n-&gt;keys);
<span class="hljs-built_in">free</span>(n-&gt;pointers);
<span class="hljs-built_in">free</span>(n);
<span class="hljs-keyword">return</span> root;
}

<span class="hljs-function">node *<span class="hljs-title">redistribute_nodes</span><span class="hljs-params">(node *root, node *n, node *neighbor, <span class="hljs-keyword">int</span> neighbor_index,
<span class="hljs-keyword">int</span> k_prime_index, <span class="hljs-keyword">int</span> k_prime)</span> </span>{
<span class="hljs-keyword">int</span> i;
node *tmp;

<span class="hljs-keyword">if</span> (neighbor_index != <span class="hljs-number">-1</span>) {
<span class="hljs-keyword">if</span> (!n-&gt;is_leaf)
n-&gt;pointers[n-&gt;num_keys + <span class="hljs-number">1</span>] = n-&gt;pointers[n-&gt;num_keys];
<span class="hljs-keyword">for</span> (i = n-&gt;num_keys; i &gt; <span class="hljs-number">0</span>; i--) {
n-&gt;keys[i] = n-&gt;keys[i - <span class="hljs-number">1</span>];
n-&gt;pointers[i] = n-&gt;pointers[i - <span class="hljs-number">1</span>];
}
<span class="hljs-keyword">if</span> (!n-&gt;is_leaf) {
n-&gt;pointers[<span class="hljs-number">0</span>] = neighbor-&gt;pointers[neighbor-&gt;num_keys];
tmp = (node *)n-&gt;pointers[<span class="hljs-number">0</span>];
tmp-&gt;parent = n;
neighbor-&gt;pointers[neighbor-&gt;num_keys] = <span class="hljs-literal">NULL</span>;
n-&gt;keys[<span class="hljs-number">0</span>] = k_prime;
n-&gt;parent-&gt;keys[k_prime_index] = neighbor-&gt;keys[neighbor-&gt;num_keys - <span class="hljs-number">1</span>];
} <span class="hljs-keyword">else</span> {
n-&gt;pointers[<span class="hljs-number">0</span>] = neighbor-&gt;pointers[neighbor-&gt;num_keys - <span class="hljs-number">1</span>];
neighbor-&gt;pointers[neighbor-&gt;num_keys - <span class="hljs-number">1</span>] = <span class="hljs-literal">NULL</span>;
n-&gt;keys[<span class="hljs-number">0</span>] = neighbor-&gt;keys[neighbor-&gt;num_keys - <span class="hljs-number">1</span>];
n-&gt;parent-&gt;keys[k_prime_index] = n-&gt;keys[<span class="hljs-number">0</span>];
}
}

<span class="hljs-keyword">else</span> {
<span class="hljs-keyword">if</span> (n-&gt;is_leaf) {
n-&gt;keys[n-&gt;num_keys] = neighbor-&gt;keys[<span class="hljs-number">0</span>];
n-&gt;pointers[n-&gt;num_keys] = neighbor-&gt;pointers[<span class="hljs-number">0</span>];
n-&gt;parent-&gt;keys[k_prime_index] = neighbor-&gt;keys[<span class="hljs-number">1</span>];
} <span class="hljs-keyword">else</span> {
n-&gt;keys[n-&gt;num_keys] = k_prime;
n-&gt;pointers[n-&gt;num_keys + <span class="hljs-number">1</span>] = neighbor-&gt;pointers[<span class="hljs-number">0</span>];
tmp = (node *)n-&gt;pointers[n-&gt;num_keys + <span class="hljs-number">1</span>];
tmp-&gt;parent = n;
n-&gt;parent-&gt;keys[k_prime_index] = neighbor-&gt;keys[<span class="hljs-number">0</span>];
}
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; neighbor-&gt;num_keys - <span class="hljs-number">1</span>; i++) {
neighbor-&gt;keys[i] = neighbor-&gt;keys[i + <span class="hljs-number">1</span>];
neighbor-&gt;pointers[i] = neighbor-&gt;pointers[i + <span class="hljs-number">1</span>];
}
<span class="hljs-keyword">if</span> (!n-&gt;is_leaf)
neighbor-&gt;pointers[i] = neighbor-&gt;pointers[i + <span class="hljs-number">1</span>];
}

n-&gt;num_keys++;
neighbor-&gt;num_keys--;

<span class="hljs-keyword">return</span> root;
}

<span class="hljs-function">node *<span class="hljs-title">delete_entry</span><span class="hljs-params">(node *root, node *n, <span class="hljs-keyword">int</span> key, <span class="hljs-keyword">void</span> *pointer)</span> </span>{
<span class="hljs-keyword">int</span> min_keys;
node *neighbor;
<span class="hljs-keyword">int</span> neighbor_index;
<span class="hljs-keyword">int</span> k_prime_index, k_prime;
<span class="hljs-keyword">int</span> capacity;

n = remove_entry_from_node(n, key, pointer);

<span class="hljs-keyword">if</span> (n == root)
<span class="hljs-keyword">return</span> adjust_root(root);

min_keys = n-&gt;is_leaf ? cut(order - <span class="hljs-number">1</span>) : cut(order) - <span class="hljs-number">1</span>;

<span class="hljs-keyword">if</span> (n-&gt;num_keys &gt;= min_keys)
<span class="hljs-keyword">return</span> root;

neighbor_index = get_neighbor_index(n);
k_prime_index = neighbor_index == <span class="hljs-number">-1</span> ? <span class="hljs-number">0</span> : neighbor_index;
k_prime = n-&gt;parent-&gt;keys[k_prime_index];
neighbor = neighbor_index == <span class="hljs-number">-1</span> ? n-&gt;parent-&gt;pointers[<span class="hljs-number">1</span>] : n-&gt;parent-&gt;pointers[neighbor_index];

capacity = n-&gt;is_leaf ? order : order - <span class="hljs-number">1</span>;

<span class="hljs-keyword">if</span> (neighbor-&gt;num_keys + n-&gt;num_keys &lt; capacity)
<span class="hljs-keyword">return</span> coalesce_nodes(root, n, neighbor, neighbor_index, k_prime);
<span class="hljs-keyword">else</span>
<span class="hljs-keyword">return</span> redistribute_nodes(root, n, neighbor, neighbor_index, k_prime_index, k_prime);
}

<span class="hljs-function">node *<span class="hljs-title">delete</span> <span class="hljs-params">(node *root, <span class="hljs-keyword">int</span> key)</span> </span>{
node *key_leaf = <span class="hljs-literal">NULL</span>;
record *key_record = <span class="hljs-literal">NULL</span>;

key_record = find(root, key, <span class="hljs-literal">false</span>, &amp;key_leaf);

<span class="hljs-keyword">if</span> (key_record != <span class="hljs-literal">NULL</span> &amp;&amp; key_leaf != <span class="hljs-literal">NULL</span>) {
root = delete_entry(root, key_leaf, key, key_record);
<span class="hljs-built_in">free</span>(key_record);
}
<span class="hljs-keyword">return</span> root;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destroy_tree_nodes</span><span class="hljs-params">(node *root)</span> </span>{
<span class="hljs-keyword">int</span> i;
<span class="hljs-keyword">if</span> (root-&gt;is_leaf)
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; root-&gt;num_keys; i++)
<span class="hljs-built_in">free</span>(root-&gt;pointers[i]);
<span class="hljs-keyword">else</span>
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; root-&gt;num_keys + <span class="hljs-number">1</span>; i++)
destroy_tree_nodes(root-&gt;pointers[i]);
<span class="hljs-built_in">free</span>(root-&gt;pointers);
<span class="hljs-built_in">free</span>(root-&gt;keys);
<span class="hljs-built_in">free</span>(root);
}

<span class="hljs-function">node *<span class="hljs-title">destroy_tree</span><span class="hljs-params">(node *root)</span> </span>{
destroy_tree_nodes(root);
<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
node *root;
<span class="hljs-keyword">char</span> instruction;

root = <span class="hljs-literal">NULL</span>;

root = insert(root, <span class="hljs-number">5</span>, <span class="hljs-number">33</span>);
root = insert(root, <span class="hljs-number">15</span>, <span class="hljs-number">21</span>);
root = insert(root, <span class="hljs-number">25</span>, <span class="hljs-number">31</span>);
root = insert(root, <span class="hljs-number">35</span>, <span class="hljs-number">41</span>);
root = insert(root, <span class="hljs-number">45</span>, <span class="hljs-number">10</span>);

print_tree(root);

root = <span class="hljs-keyword">delete</span> (root, <span class="hljs-number">5</span>);

print_tree(root);
}</code></pre></div>
</div>

<div class="code-editor__area" id="cpp-code">
<div class="pre-code-wrapper"><div title="Click to copy" class="copy-code-button"></div><pre class="exec" style="max-height: 600px;"><code class="cpp hljs"><span class="hljs-comment">// Deletion operation on a B+ tree in C++</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;climits&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> MAX = <span class="hljs-number">3</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BPTree</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> {</span>
<span class="hljs-keyword">bool</span> IS_LEAF;
<span class="hljs-keyword">int</span> *key, size;
Node **ptr;
<span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BPTree</span>;</span>

<span class="hljs-keyword">public</span>:
Node();
};
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BPTree</span> {</span>
Node *root;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, Node *, Node *)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, Node *, Node *)</span></span>;
<span class="hljs-function">Node *<span class="hljs-title">findParent</span><span class="hljs-params">(Node *, Node *)</span></span>;

<span class="hljs-keyword">public</span>:
BPTree();
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">(Node *)</span></span>;
<span class="hljs-function">Node *<span class="hljs-title">getRoot</span><span class="hljs-params">()</span></span>;
};
Node::Node() {
key = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[MAX];
ptr = <span class="hljs-keyword">new</span> Node *[MAX + <span class="hljs-number">1</span>];
}
BPTree::BPTree() {
root = <span class="hljs-literal">NULL</span>;
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BPTree::insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) {
root = <span class="hljs-keyword">new</span> Node;
root-&gt;key[<span class="hljs-number">0</span>] = x;
root-&gt;IS_LEAF = <span class="hljs-literal">true</span>;
root-&gt;size = <span class="hljs-number">1</span>;
} <span class="hljs-keyword">else</span> {
Node *cursor = root;
Node *parent;
<span class="hljs-keyword">while</span> (cursor-&gt;IS_LEAF == <span class="hljs-literal">false</span>) {
parent = cursor;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cursor-&gt;size; i++) {
<span class="hljs-keyword">if</span> (x &lt; cursor-&gt;key[i]) {
cursor = cursor-&gt;ptr[i];
<span class="hljs-keyword">break</span>;
}
<span class="hljs-keyword">if</span> (i == cursor-&gt;size - <span class="hljs-number">1</span>) {
cursor = cursor-&gt;ptr[i + <span class="hljs-number">1</span>];
<span class="hljs-keyword">break</span>;
}
}
}
<span class="hljs-keyword">if</span> (cursor-&gt;size &lt; MAX) {
<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (x &gt; cursor-&gt;key[i] &amp;&amp; i &lt; cursor-&gt;size)
i++;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = cursor-&gt;size; j &gt; i; j--) {
cursor-&gt;key[j] = cursor-&gt;key[j - <span class="hljs-number">1</span>];
}
cursor-&gt;key[i] = x;
cursor-&gt;size++;
cursor-&gt;ptr[cursor-&gt;size] = cursor-&gt;ptr[cursor-&gt;size - <span class="hljs-number">1</span>];
cursor-&gt;ptr[cursor-&gt;size - <span class="hljs-number">1</span>] = <span class="hljs-literal">NULL</span>;
} <span class="hljs-keyword">else</span> {
Node *newLeaf = <span class="hljs-keyword">new</span> Node;
<span class="hljs-keyword">int</span> virtualNode[MAX + <span class="hljs-number">1</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX; i++) {
virtualNode[i] = cursor-&gt;key[i];
}
<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j;
<span class="hljs-keyword">while</span> (x &gt; virtualNode[i] &amp;&amp; i &lt; MAX)
i++;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = MAX + <span class="hljs-number">1</span>; j &gt; i; j--) {
virtualNode[j] = virtualNode[j - <span class="hljs-number">1</span>];
}
virtualNode[i] = x;
newLeaf-&gt;IS_LEAF = <span class="hljs-literal">true</span>;
cursor-&gt;size = (MAX + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
newLeaf-&gt;size = MAX + <span class="hljs-number">1</span> - (MAX + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
cursor-&gt;ptr[cursor-&gt;size] = newLeaf;
newLeaf-&gt;ptr[newLeaf-&gt;size] = cursor-&gt;ptr[MAX];
cursor-&gt;ptr[MAX] = <span class="hljs-literal">NULL</span>;
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cursor-&gt;size; i++) {
cursor-&gt;key[i] = virtualNode[i];
}
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = cursor-&gt;size; i &lt; newLeaf-&gt;size; i++, j++) {
newLeaf-&gt;key[i] = virtualNode[j];
}
<span class="hljs-keyword">if</span> (cursor == root) {
Node *newRoot = <span class="hljs-keyword">new</span> Node;
newRoot-&gt;key[<span class="hljs-number">0</span>] = newLeaf-&gt;key[<span class="hljs-number">0</span>];
newRoot-&gt;ptr[<span class="hljs-number">0</span>] = cursor;
newRoot-&gt;ptr[<span class="hljs-number">1</span>] = newLeaf;
newRoot-&gt;IS_LEAF = <span class="hljs-literal">false</span>;
newRoot-&gt;size = <span class="hljs-number">1</span>;
root = newRoot;
} <span class="hljs-keyword">else</span> {
insertInternal(newLeaf-&gt;key[<span class="hljs-number">0</span>], parent, newLeaf);
}
}
}
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BPTree::insertInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, Node *cursor, Node *child)</span> </span>{
<span class="hljs-keyword">if</span> (cursor-&gt;size &lt; MAX) {
<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (x &gt; cursor-&gt;key[i] &amp;&amp; i &lt; cursor-&gt;size)
i++;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = cursor-&gt;size; j &gt; i; j--) {
cursor-&gt;key[j] = cursor-&gt;key[j - <span class="hljs-number">1</span>];
}
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = cursor-&gt;size + <span class="hljs-number">1</span>; j &gt; i + <span class="hljs-number">1</span>; j--) {
cursor-&gt;ptr[j] = cursor-&gt;ptr[j - <span class="hljs-number">1</span>];
}
cursor-&gt;key[i] = x;
cursor-&gt;size++;
cursor-&gt;ptr[i + <span class="hljs-number">1</span>] = child;
} <span class="hljs-keyword">else</span> {
Node *newInternal = <span class="hljs-keyword">new</span> Node;
<span class="hljs-keyword">int</span> virtualKey[MAX + <span class="hljs-number">1</span>];
Node *virtualPtr[MAX + <span class="hljs-number">2</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX; i++) {
virtualKey[i] = cursor-&gt;key[i];
}
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX + <span class="hljs-number">1</span>; i++) {
virtualPtr[i] = cursor-&gt;ptr[i];
}
<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j;
<span class="hljs-keyword">while</span> (x &gt; virtualKey[i] &amp;&amp; i &lt; MAX)
i++;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = MAX + <span class="hljs-number">1</span>; j &gt; i; j--) {
virtualKey[j] = virtualKey[j - <span class="hljs-number">1</span>];
}
virtualKey[i] = x;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = MAX + <span class="hljs-number">2</span>; j &gt; i + <span class="hljs-number">1</span>; j--) {
virtualPtr[j] = virtualPtr[j - <span class="hljs-number">1</span>];
}
virtualPtr[i + <span class="hljs-number">1</span>] = child;
newInternal-&gt;IS_LEAF = <span class="hljs-literal">false</span>;
cursor-&gt;size = (MAX + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
newInternal-&gt;size = MAX - (MAX + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = cursor-&gt;size + <span class="hljs-number">1</span>; i &lt; newInternal-&gt;size; i++, j++) {
newInternal-&gt;key[i] = virtualKey[j];
}
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = cursor-&gt;size + <span class="hljs-number">1</span>; i &lt; newInternal-&gt;size + <span class="hljs-number">1</span>; i++, j++) {
newInternal-&gt;ptr[i] = virtualPtr[j];
}
<span class="hljs-keyword">if</span> (cursor == root) {
Node *newRoot = <span class="hljs-keyword">new</span> Node;
newRoot-&gt;key[<span class="hljs-number">0</span>] = cursor-&gt;key[cursor-&gt;size];
newRoot-&gt;ptr[<span class="hljs-number">0</span>] = cursor;
newRoot-&gt;ptr[<span class="hljs-number">1</span>] = newInternal;
newRoot-&gt;IS_LEAF = <span class="hljs-literal">false</span>;
newRoot-&gt;size = <span class="hljs-number">1</span>;
root = newRoot;
} <span class="hljs-keyword">else</span> {
insertInternal(cursor-&gt;key[cursor-&gt;size], findParent(root, cursor), newInternal);
}
}
}
<span class="hljs-function">Node *<span class="hljs-title">BPTree::findParent</span><span class="hljs-params">(Node *cursor, Node *child)</span> </span>{
Node *parent;
<span class="hljs-keyword">if</span> (cursor-&gt;IS_LEAF || (cursor-&gt;ptr[<span class="hljs-number">0</span>])-&gt;IS_LEAF) {
<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
}
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cursor-&gt;size + <span class="hljs-number">1</span>; i++) {
<span class="hljs-keyword">if</span> (cursor-&gt;ptr[i] == child) {
parent = cursor;
<span class="hljs-keyword">return</span> parent;
} <span class="hljs-keyword">else</span> {
parent = findParent(cursor-&gt;ptr[i], child);
<span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">NULL</span>)
<span class="hljs-keyword">return</span> parent;
}
}
<span class="hljs-keyword">return</span> parent;
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BPTree::remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) {
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Tree empty\n"</span>;
} <span class="hljs-keyword">else</span> {
Node *cursor = root;
Node *parent;
<span class="hljs-keyword">int</span> leftSibling, rightSibling;
<span class="hljs-keyword">while</span> (cursor-&gt;IS_LEAF == <span class="hljs-literal">false</span>) {
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cursor-&gt;size; i++) {
parent = cursor;
leftSibling = i - <span class="hljs-number">1</span>;
rightSibling = i + <span class="hljs-number">1</span>;
<span class="hljs-keyword">if</span> (x &lt; cursor-&gt;key[i]) {
cursor = cursor-&gt;ptr[i];
<span class="hljs-keyword">break</span>;
}
<span class="hljs-keyword">if</span> (i == cursor-&gt;size - <span class="hljs-number">1</span>) {
leftSibling = i;
rightSibling = i + <span class="hljs-number">2</span>;
cursor = cursor-&gt;ptr[i + <span class="hljs-number">1</span>];
<span class="hljs-keyword">break</span>;
}
}
}
<span class="hljs-keyword">bool</span> found = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">int</span> pos;
<span class="hljs-keyword">for</span> (pos = <span class="hljs-number">0</span>; pos &lt; cursor-&gt;size; pos++) {
<span class="hljs-keyword">if</span> (cursor-&gt;key[pos] == x) {
found = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">break</span>;
}
}
<span class="hljs-keyword">if</span> (!found) {
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Not found\n"</span>;
<span class="hljs-keyword">return</span>;
}
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = pos; i &lt; cursor-&gt;size; i++) {
cursor-&gt;key[i] = cursor-&gt;key[i + <span class="hljs-number">1</span>];
}
cursor-&gt;size--;
<span class="hljs-keyword">if</span> (cursor == root) {
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX + <span class="hljs-number">1</span>; i++) {
cursor-&gt;ptr[i] = <span class="hljs-literal">NULL</span>;
}
<span class="hljs-keyword">if</span> (cursor-&gt;size == <span class="hljs-number">0</span>) {
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Tree died\n"</span>;
<span class="hljs-keyword">delete</span>[] cursor-&gt;key;
<span class="hljs-keyword">delete</span>[] cursor-&gt;ptr;
<span class="hljs-keyword">delete</span> cursor;
root = <span class="hljs-literal">NULL</span>;
}
<span class="hljs-keyword">return</span>;
}
cursor-&gt;ptr[cursor-&gt;size] = cursor-&gt;ptr[cursor-&gt;size + <span class="hljs-number">1</span>];
cursor-&gt;ptr[cursor-&gt;size + <span class="hljs-number">1</span>] = <span class="hljs-literal">NULL</span>;
<span class="hljs-keyword">if</span> (cursor-&gt;size &gt;= (MAX + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>) {
<span class="hljs-keyword">return</span>;
}
<span class="hljs-keyword">if</span> (leftSibling &gt;= <span class="hljs-number">0</span>) {
Node *leftNode = parent-&gt;ptr[leftSibling];
<span class="hljs-keyword">if</span> (leftNode-&gt;size &gt;= (MAX + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) {
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = cursor-&gt;size; i &gt; <span class="hljs-number">0</span>; i--) {
cursor-&gt;key[i] = cursor-&gt;key[i - <span class="hljs-number">1</span>];
}
cursor-&gt;size++;
cursor-&gt;ptr[cursor-&gt;size] = cursor-&gt;ptr[cursor-&gt;size - <span class="hljs-number">1</span>];
cursor-&gt;ptr[cursor-&gt;size - <span class="hljs-number">1</span>] = <span class="hljs-literal">NULL</span>;
cursor-&gt;key[<span class="hljs-number">0</span>] = leftNode-&gt;key[leftNode-&gt;size - <span class="hljs-number">1</span>];
leftNode-&gt;size--;
leftNode-&gt;ptr[leftNode-&gt;size] = cursor;
leftNode-&gt;ptr[leftNode-&gt;size + <span class="hljs-number">1</span>] = <span class="hljs-literal">NULL</span>;
parent-&gt;key[leftSibling] = cursor-&gt;key[<span class="hljs-number">0</span>];
<span class="hljs-keyword">return</span>;
}
}
<span class="hljs-keyword">if</span> (rightSibling &lt;= parent-&gt;size) {
Node *rightNode = parent-&gt;ptr[rightSibling];
<span class="hljs-keyword">if</span> (rightNode-&gt;size &gt;= (MAX + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) {
cursor-&gt;size++;
cursor-&gt;ptr[cursor-&gt;size] = cursor-&gt;ptr[cursor-&gt;size - <span class="hljs-number">1</span>];
cursor-&gt;ptr[cursor-&gt;size - <span class="hljs-number">1</span>] = <span class="hljs-literal">NULL</span>;
cursor-&gt;key[cursor-&gt;size - <span class="hljs-number">1</span>] = rightNode-&gt;key[<span class="hljs-number">0</span>];
rightNode-&gt;size--;
rightNode-&gt;ptr[rightNode-&gt;size] = rightNode-&gt;ptr[rightNode-&gt;size + <span class="hljs-number">1</span>];
rightNode-&gt;ptr[rightNode-&gt;size + <span class="hljs-number">1</span>] = <span class="hljs-literal">NULL</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rightNode-&gt;size; i++) {
rightNode-&gt;key[i] = rightNode-&gt;key[i + <span class="hljs-number">1</span>];
}
parent-&gt;key[rightSibling - <span class="hljs-number">1</span>] = rightNode-&gt;key[<span class="hljs-number">0</span>];
<span class="hljs-keyword">return</span>;
}
}
<span class="hljs-keyword">if</span> (leftSibling &gt;= <span class="hljs-number">0</span>) {
Node *leftNode = parent-&gt;ptr[leftSibling];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = leftNode-&gt;size, j = <span class="hljs-number">0</span>; j &lt; cursor-&gt;size; i++, j++) {
leftNode-&gt;key[i] = cursor-&gt;key[j];
}
leftNode-&gt;ptr[leftNode-&gt;size] = <span class="hljs-literal">NULL</span>;
leftNode-&gt;size += cursor-&gt;size;
leftNode-&gt;ptr[leftNode-&gt;size] = cursor-&gt;ptr[cursor-&gt;size];
removeInternal(parent-&gt;key[leftSibling], parent, cursor);
<span class="hljs-keyword">delete</span>[] cursor-&gt;key;
<span class="hljs-keyword">delete</span>[] cursor-&gt;ptr;
<span class="hljs-keyword">delete</span> cursor;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rightSibling &lt;= parent-&gt;size) {
Node *rightNode = parent-&gt;ptr[rightSibling];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = cursor-&gt;size, j = <span class="hljs-number">0</span>; j &lt; rightNode-&gt;size; i++, j++) {
cursor-&gt;key[i] = rightNode-&gt;key[j];
}
cursor-&gt;ptr[cursor-&gt;size] = <span class="hljs-literal">NULL</span>;
cursor-&gt;size += rightNode-&gt;size;
cursor-&gt;ptr[cursor-&gt;size] = rightNode-&gt;ptr[rightNode-&gt;size];
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Merging two leaf nodes\n"</span>;
removeInternal(parent-&gt;key[rightSibling - <span class="hljs-number">1</span>], parent, rightNode);
<span class="hljs-keyword">delete</span>[] rightNode-&gt;key;
<span class="hljs-keyword">delete</span>[] rightNode-&gt;ptr;
<span class="hljs-keyword">delete</span> rightNode;
}
}
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BPTree::removeInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, Node *cursor, Node *child)</span> </span>{
<span class="hljs-keyword">if</span> (cursor == root) {
<span class="hljs-keyword">if</span> (cursor-&gt;size == <span class="hljs-number">1</span>) {
<span class="hljs-keyword">if</span> (cursor-&gt;ptr[<span class="hljs-number">1</span>] == child) {
<span class="hljs-keyword">delete</span>[] child-&gt;key;
<span class="hljs-keyword">delete</span>[] child-&gt;ptr;
<span class="hljs-keyword">delete</span> child;
root = cursor-&gt;ptr[<span class="hljs-number">0</span>];
<span class="hljs-keyword">delete</span>[] cursor-&gt;key;
<span class="hljs-keyword">delete</span>[] cursor-&gt;ptr;
<span class="hljs-keyword">delete</span> cursor;
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Changed root node\n"</span>;
<span class="hljs-keyword">return</span>;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cursor-&gt;ptr[<span class="hljs-number">0</span>] == child) {
<span class="hljs-keyword">delete</span>[] child-&gt;key;
<span class="hljs-keyword">delete</span>[] child-&gt;ptr;
<span class="hljs-keyword">delete</span> child;
root = cursor-&gt;ptr[<span class="hljs-number">1</span>];
<span class="hljs-keyword">delete</span>[] cursor-&gt;key;
<span class="hljs-keyword">delete</span>[] cursor-&gt;ptr;
<span class="hljs-keyword">delete</span> cursor;
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Changed root node\n"</span>;
<span class="hljs-keyword">return</span>;
}
}
}
<span class="hljs-keyword">int</span> pos;
<span class="hljs-keyword">for</span> (pos = <span class="hljs-number">0</span>; pos &lt; cursor-&gt;size; pos++) {
<span class="hljs-keyword">if</span> (cursor-&gt;key[pos] == x) {
<span class="hljs-keyword">break</span>;
}
}
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = pos; i &lt; cursor-&gt;size; i++) {
cursor-&gt;key[i] = cursor-&gt;key[i + <span class="hljs-number">1</span>];
}
<span class="hljs-keyword">for</span> (pos = <span class="hljs-number">0</span>; pos &lt; cursor-&gt;size + <span class="hljs-number">1</span>; pos++) {
<span class="hljs-keyword">if</span> (cursor-&gt;ptr[pos] == child) {
<span class="hljs-keyword">break</span>;
}
}
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = pos; i &lt; cursor-&gt;size + <span class="hljs-number">1</span>; i++) {
cursor-&gt;ptr[i] = cursor-&gt;ptr[i + <span class="hljs-number">1</span>];
}
cursor-&gt;size--;
<span class="hljs-keyword">if</span> (cursor-&gt;size &gt;= (MAX + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>) {
<span class="hljs-keyword">return</span>;
}
<span class="hljs-keyword">if</span> (cursor == root)
<span class="hljs-keyword">return</span>;
Node *parent = findParent(root, cursor);
<span class="hljs-keyword">int</span> leftSibling, rightSibling;
<span class="hljs-keyword">for</span> (pos = <span class="hljs-number">0</span>; pos &lt; parent-&gt;size + <span class="hljs-number">1</span>; pos++) {
<span class="hljs-keyword">if</span> (parent-&gt;ptr[pos] == cursor) {
leftSibling = pos - <span class="hljs-number">1</span>;
rightSibling = pos + <span class="hljs-number">1</span>;
<span class="hljs-keyword">break</span>;
}
}
<span class="hljs-keyword">if</span> (leftSibling &gt;= <span class="hljs-number">0</span>) {
Node *leftNode = parent-&gt;ptr[leftSibling];
<span class="hljs-keyword">if</span> (leftNode-&gt;size &gt;= (MAX + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>) {
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = cursor-&gt;size; i &gt; <span class="hljs-number">0</span>; i--) {
cursor-&gt;key[i] = cursor-&gt;key[i - <span class="hljs-number">1</span>];
}
cursor-&gt;key[<span class="hljs-number">0</span>] = parent-&gt;key[leftSibling];
parent-&gt;key[leftSibling] = leftNode-&gt;key[leftNode-&gt;size - <span class="hljs-number">1</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = cursor-&gt;size + <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) {
cursor-&gt;ptr[i] = cursor-&gt;ptr[i - <span class="hljs-number">1</span>];
}
cursor-&gt;ptr[<span class="hljs-number">0</span>] = leftNode-&gt;ptr[leftNode-&gt;size];
cursor-&gt;size++;
leftNode-&gt;size--;
<span class="hljs-keyword">return</span>;
}
}
<span class="hljs-keyword">if</span> (rightSibling &lt;= parent-&gt;size) {
Node *rightNode = parent-&gt;ptr[rightSibling];
<span class="hljs-keyword">if</span> (rightNode-&gt;size &gt;= (MAX + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>) {
cursor-&gt;key[cursor-&gt;size] = parent-&gt;key[pos];
parent-&gt;key[pos] = rightNode-&gt;key[<span class="hljs-number">0</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rightNode-&gt;size - <span class="hljs-number">1</span>; i++) {
rightNode-&gt;key[i] = rightNode-&gt;key[i + <span class="hljs-number">1</span>];
}
cursor-&gt;ptr[cursor-&gt;size + <span class="hljs-number">1</span>] = rightNode-&gt;ptr[<span class="hljs-number">0</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rightNode-&gt;size; ++i) {
rightNode-&gt;ptr[i] = rightNode-&gt;ptr[i + <span class="hljs-number">1</span>];
}
cursor-&gt;size++;
rightNode-&gt;size--;
<span class="hljs-keyword">return</span>;
}
}
<span class="hljs-keyword">if</span> (leftSibling &gt;= <span class="hljs-number">0</span>) {
Node *leftNode = parent-&gt;ptr[leftSibling];
leftNode-&gt;key[leftNode-&gt;size] = parent-&gt;key[leftSibling];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = leftNode-&gt;size + <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; j &lt; cursor-&gt;size; j++) {
leftNode-&gt;key[i] = cursor-&gt;key[j];
}
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = leftNode-&gt;size + <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; j &lt; cursor-&gt;size + <span class="hljs-number">1</span>; j++) {
leftNode-&gt;ptr[i] = cursor-&gt;ptr[j];
cursor-&gt;ptr[j] = <span class="hljs-literal">NULL</span>;
}
leftNode-&gt;size += cursor-&gt;size + <span class="hljs-number">1</span>;
cursor-&gt;size = <span class="hljs-number">0</span>;
removeInternal(parent-&gt;key[leftSibling], parent, cursor);
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rightSibling &lt;= parent-&gt;size) {
Node *rightNode = parent-&gt;ptr[rightSibling];
cursor-&gt;key[cursor-&gt;size] = parent-&gt;key[rightSibling - <span class="hljs-number">1</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = cursor-&gt;size + <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; j &lt; rightNode-&gt;size; j++) {
cursor-&gt;key[i] = rightNode-&gt;key[j];
}
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = cursor-&gt;size + <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; j &lt; rightNode-&gt;size + <span class="hljs-number">1</span>; j++) {
cursor-&gt;ptr[i] = rightNode-&gt;ptr[j];
rightNode-&gt;ptr[j] = <span class="hljs-literal">NULL</span>;
}
cursor-&gt;size += rightNode-&gt;size + <span class="hljs-number">1</span>;
rightNode-&gt;size = <span class="hljs-number">0</span>;
removeInternal(parent-&gt;key[rightSibling - <span class="hljs-number">1</span>], parent, rightNode);
}
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BPTree::display</span><span class="hljs-params">(Node *cursor)</span> </span>{
<span class="hljs-keyword">if</span> (cursor != <span class="hljs-literal">NULL</span>) {
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cursor-&gt;size; i++) {
<span class="hljs-built_in">cout</span> &lt;&lt; cursor-&gt;key[i] &lt;&lt; <span class="hljs-string">" "</span>;
}
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n"</span>;
<span class="hljs-keyword">if</span> (cursor-&gt;IS_LEAF != <span class="hljs-literal">true</span>) {
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cursor-&gt;size + <span class="hljs-number">1</span>; i++) {
display(cursor-&gt;ptr[i]);
}
}
}
}
<span class="hljs-function">Node *<span class="hljs-title">BPTree::getRoot</span><span class="hljs-params">()</span> </span>{
<span class="hljs-keyword">return</span> root;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
BPTree node;
node.insert(<span class="hljs-number">5</span>);
node.insert(<span class="hljs-number">15</span>);
node.insert(<span class="hljs-number">25</span>);
node.insert(<span class="hljs-number">35</span>);
node.insert(<span class="hljs-number">45</span>);

node.display(node.getRoot());

node.remove(<span class="hljs-number">15</span>);

node.display(node.getRoot());
}
</code></pre></div>

<hr><h2 id="complexity"><code>Deletion Complexity</code></h2>

<p><code>Time complexity: <code>Θ(t.log<sub>t</sub> n)</code></code></p>

<p><code>The complexity is dominated by <code>Θ(log<sub>t</sub> n)</code>.</code></p>

<p></p>
</div>
</div>
</div>



</div>


        <div class="tutorial-toc"><div class="tutorial-toc__inner"><h3 class="tutorial-toc__title">Table of Contents
<button class="btn btn--clear align-items-center">
<svg class="programiz-icon"><use xlink:href="/sites/all/themes/programiz/assets/feather-sprite.svg#x"></use></svg></button></h3><div class="tutorial-toc__links"><ul><li><a href="#definition">Definition</a></li>
<li><a href="#deletion">Deletion Operation</a></li>
<li><a href="#code">Python, Java and C/C++ Examples</a></li>
<li><a href="#complexity">Deletion Complexity</a></li>
</ul></div></div></div>                          </div>
<!--second------------------------------------------->
<div>
<ul>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/stack.html">

        Stack</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/queue.html">

        Queue</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/types-of-queue.html">

        Types of Queue</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/circular-queue.html">

        Circular Queue</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/priority-queue.html">

        Priority Queue</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/deque.html">

        Deque</a></button>
<br/>
<br/>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/linked-list.html">

        Linked List</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/linked-list-operations.html">

        Linked List Operations</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/linked-list-types.html">

        Types of Linked List</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/hash-table.html">

        Hash Table</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/heap-data-structure.html">

        Heap Data Structure</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/fibonacci-heap.html">

        Fibonacci Heap</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/decrease-key-and-delete-node-from-a-fibonacci-heap.html">

        Decrease Key and Delete node from Fibonacci Heap</a></button>
<br>
<br/>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/trees.html">

        Tree Data Structure</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/tree-traversal.html">

        Tree Traversal</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/binary-tree.html">

        Binary Tree</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/full-binary-tree.html">

        Full Binary Tree</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/perfect-binary-tree.html">

        Perfect Binary Tree</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/complete-binary-tree.html">

        Complete Binary Tree</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/balanced-binary-tree.html">

        Balanced Binary Tree</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/binary-search-tree.html">

        Binary Search Tree</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/avl-tree.html">

        AVL Tree</a></button>
<br>
<br/>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/b-tree.html">

        B Tree</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/insertion-into-a-b-tree.html">

        Insertion into B-tree</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/deletion-from-a-b-tree.html">

        Deletion from B-tree</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/b-plus-tree.html">

        B+ Tree</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/insertion-on-a-b-plus-tree.html">

        Insertion on a B+ Tree</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/deletion-from-a-b-plus-tree.html">

        Deletion from a B+ Tree</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/red-black-tree.html">

        Red Black Tree</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/insertion-in-a-red-black-tree.html">

        Insertion in Red Black Tree</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/deletion-from-a-red-black-tree.html">

        Deletion from Red Black Tree</a></button>
<br>
<br/>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/graph.html">

        Graph Data Structure</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/spanning-tree-and-minimum-spanning-tree.html">

        Spanning Tree</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/strongly-connected-components.html">

        Strongly Connected Components</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/graph-adjacency-matrix.html">

        Adjacency Matrix</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/graph-adjacency-list.html">

        Adjacency List</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/graph-dfs.html">

        DFS Algorithm</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/graph-bfs.html">

        Breadth-first Search</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/bellman-ford-algorithm.html">

        Bellman Ford's Algorithm</a></button>
<br>
<br/>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/bubble-sort.html">

        Bubble Sort</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/selection-sort.html">

        Selection Sort</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/insertion-sort.html">

        Insertion Sort</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/merge-sort.html">

        Merge Sort</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/quick-sort.html">

        Quick Sort</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/counting-sort.html">

        Counting Sort</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/radix-sort.html">

        Radix Sort</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/bucket-sort.html">

        Bucket Sort</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/heap-sort.html">

        Heap Sort</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/shell-sort.html">

        Shell Sort</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/linear-search.html">

        Linear Search</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/binary-search.html">

        Binary Search</a></button>
<br>
<br/>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/greedy-algorithm.html">

        Greedy Algorithm</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/ford-fulkerson-algorithm.html">

        Ford-Fulkerson Algorithm</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/dijkstra-algorithm.html">

        Dijkstra's Algorithm</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/kruskal-algorithm.html">

        Kruskal's Algorithm</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/prim-algorithm.html">

        Prim's Algorithm</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/huffman-coding.html">

        Huffman Code</a></button>
<br>
<br/>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/dynamic-programming.html">

        Dynamic Programming</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/floyd-warshall-algorithm.html">

        Floyd Warshall Algorithm</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/longest-common-subsequence.html">

        Longest Common Subsequence</a></button>
<br>
<br/>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/backtracking-algorithm.html">

        Backtracking Algorithm</a></button>
<button style="padding:5px; margin-bottom:2px"><a href="

        /dsa/rabin-karp-algorithm.html">

        Rabin-Karp Algorithm</a></button>
<br>
<br/>
<h2>Free Courses on YouTube</h2>
<br/>
<img height="35px" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgT9Spnddn1UerjXEbcWQUPhfDHLL9rppkmUp1x4JRPKsdTwmX0kI26Rd0-2qKlwGAAnbgiPz7dZMm5Rv5Fd1QLhkQC6n3ob13ug1bTYtizkDpk2B0LxRiA8QUIjeTmfu6vZHoKJ7pXUgt73sHoXvSpGWjKQ6ZM01IIbJnXmwzXq4RdNYA4swdULgNy/s16000/youtube-logo.png" width="35px"/>
<button style="padding:5px; margin-bottom:2px"><a href="

            https://www.youtube.com/watch?v=IbSXF7eT-AU&amp;list=PLR_5PTwg_uAQw40OhdvAwN4NvzWv0xOZ2">

            Python Full Course Playlist</a></button>
<br/>
<img height="35px" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgT9Spnddn1UerjXEbcWQUPhfDHLL9rppkmUp1x4JRPKsdTwmX0kI26Rd0-2qKlwGAAnbgiPz7dZMm5Rv5Fd1QLhkQC6n3ob13ug1bTYtizkDpk2B0LxRiA8QUIjeTmfu6vZHoKJ7pXUgt73sHoXvSpGWjKQ6ZM01IIbJnXmwzXq4RdNYA4swdULgNy/s16000/youtube-logo.png" width="35px"/>
<button style="padding:5px; margin-bottom:2px"><a href="https://www.youtube.com/watch?v=UEl6wB90Gs8">

            105 STL Algorithms in Less Than an Hour</a></button>
<br/>
<img height="35px" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgT9Spnddn1UerjXEbcWQUPhfDHLL9rppkmUp1x4JRPKsdTwmX0kI26Rd0-2qKlwGAAnbgiPz7dZMm5Rv5Fd1QLhkQC6n3ob13ug1bTYtizkDpk2B0LxRiA8QUIjeTmfu6vZHoKJ7pXUgt73sHoXvSpGWjKQ6ZM01IIbJnXmwzXq4RdNYA4swdULgNy/s16000/youtube-logo.png" width="35px"/>
<button style="padding:5px; margin-bottom:2px"><a href="https://www.youtube.com/watch?v=zZXTgN7L1UU&amp;list=PLR_5PTwg_uAS6C1cSMjU6oVhOcCX8Zu_4">

            C++ STL Playlist</a></button>
<br/>
<img height="35px" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgT9Spnddn1UerjXEbcWQUPhfDHLL9rppkmUp1x4JRPKsdTwmX0kI26Rd0-2qKlwGAAnbgiPz7dZMm5Rv5Fd1QLhkQC6n3ob13ug1bTYtizkDpk2B0LxRiA8QUIjeTmfu6vZHoKJ7pXUgt73sHoXvSpGWjKQ6ZM01IIbJnXmwzXq4RdNYA4swdULgNy/s16000/youtube-logo.png" width="35px"/>
<button style="padding:5px; margin-bottom:2px"><a href="https://youtu.be/ty9756v3kc8">

            Learn Node.js </a></button>
<br/>
<img height="35px" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgT9Spnddn1UerjXEbcWQUPhfDHLL9rppkmUp1x4JRPKsdTwmX0kI26Rd0-2qKlwGAAnbgiPz7dZMm5Rv5Fd1QLhkQC6n3ob13ug1bTYtizkDpk2B0LxRiA8QUIjeTmfu6vZHoKJ7pXUgt73sHoXvSpGWjKQ6ZM01IIbJnXmwzXq4RdNYA4swdULgNy/s16000/youtube-logo.png" width="35px"/>
<button style="padding:5px; margin-bottom:2px"><a href="https://youtu.be/exrIpdS3Crc">

            Learn Data Science Full course</a></button>
<br/>
<img height="35px" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgT9Spnddn1UerjXEbcWQUPhfDHLL9rppkmUp1x4JRPKsdTwmX0kI26Rd0-2qKlwGAAnbgiPz7dZMm5Rv5Fd1QLhkQC6n3ob13ug1bTYtizkDpk2B0LxRiA8QUIjeTmfu6vZHoKJ7pXUgt73sHoXvSpGWjKQ6ZM01IIbJnXmwzXq4RdNYA4swdULgNy/s16000/youtube-logo.png" width="35px"/>
<button style="padding:5px; margin-bottom:2px"><a href="https://youtu.be/Q8tDO2uSk5U">

            Learn Computer Networking Full course</a></button>
<br/>
</br></br></br></br></br></br></br></br></ul>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<footer class="afooter" style="margin-left:20px">
<p>
<a href="/cookie-policy.html">Cookie policy</a> |

        <a href="/privacy-policy.html">Privacy policy</a> |

        <a href="/terms-of-use.html">Terms of use</a> |

        <a href="/disclaimer.html">Disclaimer</a> |

        <a href="/about-us.html">About Us</a>
</p>
<p>

        © 2023 <a href="https://pythonread.github.io">https://pythonread.github.io</a>
</p>
</footer>
<script type="text/javascript">

    document.addEventListener('DOMContentLoaded', function () { htmlTableOfContents() }); function htmlTableOfContents(documentRef) { var documentRef = documentRef || document; var toc = documentRef.getElementById("toc"); var headings = [].slice.call(documentRef.body.querySelectorAll('h2, h3')); headings.forEach(function (heading, index) { var ref = "toc" + index; if (heading.hasAttribute("id")) { ref = heading.getAttribute("id") } else { heading.setAttribute("id", ref) } var link = documentRef.createElement("a"); link.setAttribute("href", "#" + ref); link.textContent = heading.textContent; var div = documentRef.createElement("div"); div.setAttribute("class", heading.tagName.toLowerCase()); div.appendChild(link); toc.appendChild(div) }) } try { module.exports = htmlTableOfContents } catch (e) { } function isScrolledIntoView(el) { var rect = el.getBoundingClientRect(); var elemTop = rect.top; var elemBottom = rect.bottom; var isVisible = (elemTop >= -10) && (elemBottom <= (window.innerHeight)); return isVisible } function highlightMenu() { var headers = document.querySelectorAll("h2, h3"); for (var i = 0; i < headers.length; i += 1) { if (isScrolledIntoView(headers[i])) { var childDivs = document.getElementById('toc').getElementsByTagName('div'); var c = childDivs[i].classList; c.add("active"); for (var j = 0; j < i; j += 1) { var c = childDivs[j].classList; c.remove("active") } for (var j = i + 1; j < childDivs.length; j += 1) { var c = childDivs[j].classList; c.remove("active") } break } } } function highlightMenuLastItem() { var childDivs = document.getElementById('toc').getElementsByTagName('div'); for (var j = 0; j < childDivs.length - 1; j += 1) { var c = childDivs[j].classList; c.remove("active") } var c = childDivs[childDivs.length - 1].classList; c.add("active") } window.addEventListener("click", function (event) { highlightMenu() }); window.onscroll = function (e) { highlightMenu(); if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight) { highlightMenuLastItem() } }; function mobileMenu() { var classes = document.getElementById('nav-toggle-icon').classList; if (classes.contains("active")) { classes.remove("active") } else { classes.add("active") } var classes = document.getElementById('menu-wrapper').classList; if (classes.contains("active")) { classes.remove("active") } else { classes.add("active") } }

</script>
<script type="text/javascript">

    function changepy(){

        document.getElementById('py1').className = 'tabbed-editor__node tabbed-editor__node--active';

        document.getElementById('java1').className = 'tabbed-editor__node';

        document.getElementById('c1').className = 'tabbed-editor__node';

        document.getElementById('cpp1').className = 'tabbed-editor__node';

        document.getElementById('python-code').className = 'code-editor__area code-editor__area--active';

        document.getElementById('java-code').className = 'code-editor__area';

        document.getElementById('c-code').className = 'code-editor__area';

        document.getElementById('cpp-code').className = 'code-editor__area';



    }

    function changecpp(){

        document.getElementById('py1').className = 'tabbed-editor__node';

        document.getElementById('java1').className = 'tabbed-editor__node';

        document.getElementById('c1').className = 'tabbed-editor__node';

        document.getElementById('cpp1').className = 'tabbed-editor__node tabbed-editor__node--active';

        document.getElementById('python-code').className = 'code-editor__area';

        document.getElementById('java-code').className = 'code-editor__area';

        document.getElementById('c-code').className = 'code-editor__area';

        document.getElementById('cpp-code').className = 'code-editor__area code-editor__area--active';

    }

    function changejava(){

       document.getElementById('py1').className = 'tabbed-editor__node';

        document.getElementById('java1').className = 'tabbed-editor__node tabbed-editor__node--active';

        document.getElementById('c1').className = 'tabbed-editor__node';

        document.getElementById('cpp1').className = 'tabbed-editor__node';

        document.getElementById('python-code').className = 'code-editor__area';

        document.getElementById('java-code').className = 'code-editor__area code-editor__area--active';

        document.getElementById('c-code').className = 'code-editor__area';

        document.getElementById('cpp-code').className = 'code-editor__area';

    }

    function changec(){

        document.getElementById('py1').className = 'tabbed-editor__node';

        document.getElementById('java1').className = 'tabbed-editor__node';

        document.getElementById('c1').className = 'tabbed-editor__node tabbed-editor__node--active';

        document.getElementById('cpp1').className = 'tabbed-editor__node';

        document.getElementById('python-code').className = 'code-editor__area';

        document.getElementById('java-code').className = 'code-editor__area';

        document.getElementById('c-code').className = 'code-editor__area code-editor__area--active';

        document.getElementById('cpp-code').className = 'code-editor__area';

    }

    

</script>
<!-- Code injected by live-server -->
<script>
	// <![CDATA[  <-- For SVG support
	if ('WebSocket' in window) {
		(function () {
			function refreshCSS() {
				var sheets = [].slice.call(document.getElementsByTagName("link"));
				var head = document.getElementsByTagName("head")[0];
				for (var i = 0; i < sheets.length; ++i) {
					var elem = sheets[i];
					var parent = elem.parentElement || head;
					parent.removeChild(elem);
					var rel = elem.rel;
					if (elem.href && typeof rel != "string" || rel.length == 0 || rel.toLowerCase() == "stylesheet") {
						var url = elem.href.replace(/(&|\?)_cacheOverride=\d+/, '');
						elem.href = url + (url.indexOf('?') >= 0 ? '&' : '?') + '_cacheOverride=' + (new Date().valueOf());
					}
					parent.appendChild(elem);
				}
			}
			var protocol = window.location.protocol === 'http:' ? 'ws://' : 'wss://';
			var address = protocol + window.location.host + window.location.pathname + '/ws';
			var socket = new WebSocket(address);
			socket.onmessage = function (msg) {
				if (msg.data == 'reload') window.location.reload();
				else if (msg.data == 'refreshcss') refreshCSS();
			};
			if (sessionStorage && !sessionStorage.getItem('IsThisFirstTime_Log_From_LiveServer')) {
				console.log('Live reload enabled.');
				sessionStorage.setItem('IsThisFirstTime_Log_From_LiveServer', true);
			}
		})();
	}
	else {
		console.error('Upgrade your browser. This Browser is NOT supported WebSocket for Live-Reloading.');
	}
	// ]]>
</script>
</body>
</html>